webpackHotUpdate("static/development/pages/index.js",{

/***/ "./components/Form.js":
/*!****************************!*\
  !*** ./components/Form.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Form; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-hook-form */ \"./node_modules/react-hook-form/dist/react-hook-form.es.js\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles.module.scss */ \"./components/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_2__);\nvar _jsxFileName = \"/Users/angus.clarktrussle.com/Downloads/Work/react-hooks-form/components/Form.js\";\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\nfunction Form() {\n  return __jsx(\"div\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['form-container'],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 7,\n      columnNumber: 5\n    }\n  }, __jsx(\"div\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['inner-wrapper'],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 7\n    }\n  }, __jsx(\"h1\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['title'],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 9,\n      columnNumber: 9\n    }\n  }, \" Create Your Account \"), __jsx(\"form\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['form'],\n    action: \"\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 10,\n      columnNumber: 9\n    }\n  }, __jsx(\"div\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['form-section'],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 11,\n      columnNumber: 11\n    }\n  }, __jsx(\"label\", {\n    htmlFor: \"company-name\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 13\n    }\n  }, \"Company Name\"), __jsx(\"input\", {\n    type: \"text\",\n    name: \"company-name\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 13,\n      columnNumber: 13\n    }\n  })), __jsx(\"div\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['form-section'],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 11\n    }\n  }, __jsx(\"label\", {\n    htmlFor: \"your-name\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 13\n    }\n  }, \"Your Name\"), __jsx(\"input\", {\n    type: \"text\",\n    name: \"your-name\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 17,\n      columnNumber: 13\n    }\n  })), __jsx(\"div\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['form-section'],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 19,\n      columnNumber: 11\n    }\n  }, __jsx(\"label\", {\n    htmlFor: \"email-address\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 20,\n      columnNumber: 13\n    }\n  }, \"Email Address\"), __jsx(\"input\", {\n    type: \"text\",\n    name: \"email-address\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 21,\n      columnNumber: 13\n    }\n  })), __jsx(\"div\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['form-section'],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23,\n      columnNumber: 11\n    }\n  }, __jsx(\"label\", {\n    htmlFor: \"password\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 24,\n      columnNumber: 13\n    }\n  }, \"Password\"), __jsx(\"input\", {\n    type: \"password\",\n    name: \"password\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 25,\n      columnNumber: 13\n    }\n  })), __jsx(\"div\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['form-section'],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 27,\n      columnNumber: 11\n    }\n  }, __jsx(\"input\", {\n    type: \"checkbox\",\n    name: \"register-checkbox\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 13\n    }\n  }), __jsx(\"label\", {\n    htmlFor: \"register-checkbox\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 13\n    }\n  }, \"To register with us please tick to agree to our \", __jsx(\"a\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 96\n    }\n  }, \"Terms and conditions\"))), __jsx(\"button\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 31,\n      columnNumber: 11\n    }\n  }, \"Register\")), __jsx(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 9\n    }\n  })), __jsx(\"p\", {\n    className: _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a['sign-in-link'],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 7\n    }\n  }, \"Already have an account? \", __jsx(\"a\", {\n    href: \"\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 70\n    }\n  }, \"Sign in\"), \" \"));\n}\n_c = Form;\n\nvar _c;\n\n$RefreshReg$(_c, \"Form\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports_1 = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports_1;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0Zvcm0uanM/NDcyOSJdLCJuYW1lcyI6WyJGb3JtIiwic3R5bGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFFZSxTQUFTQSxJQUFULEdBQWdCO0FBQzdCLFNBQ0U7QUFBSyxhQUFTLEVBQUVDLDBEQUFNLENBQUMsZ0JBQUQsQ0FBdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFO0FBQUssYUFBUyxFQUFFQSwwREFBTSxDQUFDLGVBQUQsQ0FBdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFO0FBQUksYUFBUyxFQUFFQSwwREFBTSxDQUFDLE9BQUQsQ0FBckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw2QkFERixFQUVFO0FBQU0sYUFBUyxFQUFFQSwwREFBTSxDQUFDLE1BQUQsQ0FBdkI7QUFBaUMsVUFBTSxFQUFDLEVBQXhDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRTtBQUFLLGFBQVMsRUFBRUEsMERBQU0sQ0FBQyxjQUFELENBQXRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRTtBQUFPLFdBQU8sRUFBQyxjQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0JBREYsRUFFRTtBQUFPLFFBQUksRUFBQyxNQUFaO0FBQW1CLFFBQUksRUFBQyxjQUF4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRkYsQ0FERixFQUtFO0FBQUssYUFBUyxFQUFFQSwwREFBTSxDQUFDLGNBQUQsQ0FBdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFO0FBQU8sV0FBTyxFQUFDLFdBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFERixFQUVFO0FBQU8sUUFBSSxFQUFDLE1BQVo7QUFBbUIsUUFBSSxFQUFDLFdBQXhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFGRixDQUxGLEVBU0U7QUFBSyxhQUFTLEVBQUVBLDBEQUFNLENBQUMsY0FBRCxDQUF0QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQ0U7QUFBTyxXQUFPLEVBQUMsZUFBZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQURGLEVBRUU7QUFBTyxRQUFJLEVBQUMsTUFBWjtBQUFtQixRQUFJLEVBQUMsZUFBeEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUZGLENBVEYsRUFhRTtBQUFLLGFBQVMsRUFBRUEsMERBQU0sQ0FBQyxjQUFELENBQXRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRTtBQUFPLFdBQU8sRUFBQyxVQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBREYsRUFFRTtBQUFPLFFBQUksRUFBQyxVQUFaO0FBQXVCLFFBQUksRUFBQyxVQUE1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRkYsQ0FiRixFQWlCRTtBQUFLLGFBQVMsRUFBRUEsMERBQU0sQ0FBQyxjQUFELENBQXRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRTtBQUFPLFFBQUksRUFBQyxVQUFaO0FBQXVCLFFBQUksRUFBQyxtQkFBNUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQURGLEVBRUU7QUFBTyxXQUFPLEVBQUMsbUJBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx5REFBbUY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw0QkFBbkYsQ0FGRixDQWpCRixFQXFCRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQXJCRixDQUZGLEVBeUJFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUF6QkYsQ0FERixFQTZCRTtBQUFHLGFBQVMsRUFBRUEsMERBQU0sQ0FBQyxjQUFELENBQXBCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0NBQStEO0FBQUcsUUFBSSxFQUFDLEVBQVI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUEvRCxNQTdCRixDQURGO0FBaUNEO0tBbEN1QkQsSSIsImZpbGUiOiIuL2NvbXBvbmVudHMvRm9ybS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZUZvcm0gfSBmcm9tIFwicmVhY3QtaG9vay1mb3JtXCI7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLm1vZHVsZS5zY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGb3JtKCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXNbJ2Zvcm0tY29udGFpbmVyJ119PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlc1snaW5uZXItd3JhcHBlciddfT5cbiAgICAgICAgPGgxIGNsYXNzTmFtZT17c3R5bGVzWyd0aXRsZSddfT4gQ3JlYXRlIFlvdXIgQWNjb3VudCA8L2gxPlxuICAgICAgICA8Zm9ybSBjbGFzc05hbWU9e3N0eWxlc1snZm9ybSddfSBhY3Rpb249XCJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzWydmb3JtLXNlY3Rpb24nXX0+XG4gICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cImNvbXBhbnktbmFtZVwiPkNvbXBhbnkgTmFtZTwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPSdjb21wYW55LW5hbWUnIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlc1snZm9ybS1zZWN0aW9uJ119PlxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJ5b3VyLW5hbWVcIj5Zb3VyIE5hbWU8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT0neW91ci1uYW1lJyAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXNbJ2Zvcm0tc2VjdGlvbiddfT5cbiAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiZW1haWwtYWRkcmVzc1wiPkVtYWlsIEFkZHJlc3M8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT0nZW1haWwtYWRkcmVzcycgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzWydmb3JtLXNlY3Rpb24nXX0+XG4gICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cInBhc3N3b3JkXCI+UGFzc3dvcmQ8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIG5hbWU9J3Bhc3N3b3JkJyAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXNbJ2Zvcm0tc2VjdGlvbiddfT5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwicmVnaXN0ZXItY2hlY2tib3hcIiAvPlxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJyZWdpc3Rlci1jaGVja2JveFwiPlRvIHJlZ2lzdGVyIHdpdGggdXMgcGxlYXNlIHRpY2sgdG8gYWdyZWUgdG8gb3VyIDxhPlRlcm1zIGFuZCBjb25kaXRpb25zPC9hPjwvbGFiZWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGJ1dHRvbj5SZWdpc3RlcjwvYnV0dG9uPlxuICAgICAgICA8L2Zvcm0+XG4gICAgICAgIDxkaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8cCBjbGFzc05hbWU9e3N0eWxlc1snc2lnbi1pbi1saW5rJ119PkFscmVhZHkgaGF2ZSBhbiBhY2NvdW50PyA8YSBocmVmPVwiXCI+U2lnbiBpbjwvYT4gPC9wPlxuICAgIDwvZGl2PlxuICApXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Form.js\n");

/***/ }),

/***/ "./node_modules/react-hook-form/dist/react-hook-form.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-hook-form/dist/react-hook-form.es.js ***!
  \*****************************************************************/
/*! exports provided: Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Controller\", function() { return Controller; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ErrorMessage\", function() { return ErrorMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FormContext\", function() { return FormContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFieldArray\", function() { return useFieldArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useForm\", function() { return useForm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFormContext\", function() { return useFormContext; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar isNullOrUndefined = (value) => value == null;\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nvar isHTMLElement = (value) => isObject(value) && value.nodeType === Node.ELEMENT_NODE;\n\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n};\r\nconst VALUE = 'value';\r\nconst UNDEFINED = 'undefined';\r\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst SELECT = 'select';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\r\nconst REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\nconst REGEX_IS_PLAIN_PROP = /^\\w*$/;\r\nconst REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\nconst REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\r\nconst REGEX_ARRAY_FIELD_INDEX = /[\\d+]/g;\n\nfunction attachEventListeners({ field: { ref }, handleChange, isRadioOrCheckbox, }) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isKey = (value) => !isArray(value) &&\r\n    (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\n\nvar stringToPath = (string) => {\r\n    const result = [];\r\n    string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {\r\n        result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\r\n    });\r\n    return result;\r\n};\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!isKey(key)) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = path\r\n        .split(/[,[\\].]+?/)\r\n        .filter(Boolean)\r\n        .reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nfunction castPath(value) {\r\n    return isArray(value) ? value : stringToPath(value);\r\n}\r\nfunction baseGet(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return index == length ? object : undefined;\r\n}\r\nfunction baseSlice(array, start, end) {\r\n    let index = -1;\r\n    let length = array.length;\r\n    if (start < 0) {\r\n        start = -start > length ? 0 : length + start;\r\n    }\r\n    end = end > length ? length : end;\r\n    if (end < 0) {\r\n        end += length;\r\n    }\r\n    length = start > end ? 0 : end - start;\r\n    const result = Array(length);\r\n    while (++index < length) {\r\n        result[index] = array[index + start];\r\n    }\r\n    return result;\r\n}\r\nfunction parent(object, path) {\r\n    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n}\r\nfunction baseUnset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const childObject = parent(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    const result = !(childObject != null) || delete childObject[key];\r\n    let previousObjRef = undefined;\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index) {\r\n                if ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (isArray(objectRef) &&\r\n                        !objectRef.filter((data) => isObject(data) && !isEmptyObject(data))\r\n                            .length)) {\r\n                    previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n                }\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction unset(object, paths) {\r\n    paths.forEach((path) => {\r\n        baseUnset(object, path);\r\n    });\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\r\n    const { ref, ref: { name, type }, mutationWatcher, } = field;\r\n    const fieldValue = fields[name];\r\n    if (!type) {\r\n        delete fields[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldValue) {\r\n        const { options } = fieldValue;\r\n        if (isArray(options) && options.length) {\r\n            options.filter(Boolean).forEach((option, index) => {\r\n                const { ref, mutationWatcher } = option;\r\n                if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\r\n                    removeAllEventListeners(ref, handleChange);\r\n                    if (mutationWatcher) {\r\n                        mutationWatcher.disconnect();\r\n                    }\r\n                    unset(options, [`[${index}]`]);\r\n                }\r\n            });\r\n            if (options && !options.filter(Boolean).length) {\r\n                delete fields[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fields[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldValue, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        if (mutationWatcher) {\r\n            mutationWatcher.disconnect();\r\n        }\r\n        delete fields[name];\r\n    }\r\n}\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nvar isEmptyString = (value) => value === '';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || isEmptyString(value)\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fields, ref) {\r\n    const { name, value } = ref;\r\n    const field = fields[name];\r\n    if (isFileInput(ref)) {\r\n        return ref.files;\r\n    }\r\n    if (isRadioInput(ref)) {\r\n        return field ? getRadioValue(field.options).value : '';\r\n    }\r\n    if (isMultipleSelect(ref)) {\r\n        return getMultipleSelectValue(ref.options);\r\n    }\r\n    if (isCheckBoxInput(ref)) {\r\n        return field ? getCheckboxValue(field.options).value : false;\r\n    }\r\n    return value;\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fields, search) => {\r\n    const output = {};\r\n    for (const name in fields) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : isArray(search)\r\n                    ? search.find((data) => name.startsWith(data))\r\n                    : search && search.nest)) {\r\n            output[name] = getFieldValue(fields, fields[name].ref);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar compareObject = (objectA = {}, objectB = {}) => {\r\n    const objectAKeys = Object.keys(objectA);\r\n    const objectBKeys = Object.keys(objectB);\r\n    return (objectAKeys.length === objectBKeys.length &&\r\n        objectAKeys.every((key) => objectB[key] && objectB[key] === objectA[key]));\r\n};\n\nvar isSameError = (error, { type, types, message }) => isObject(error) &&\r\n    error.type === type &&\r\n    error.message === message &&\r\n    compareObject(error.types, types);\n\nfunction shouldRenderBasedOnError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isFieldValid = isEmptyObject(error);\r\n    const isFormValid = isEmptyObject(errors);\r\n    const currentFieldError = get(error, name);\r\n    const existFieldError = get(errors, name);\r\n    if ((isFieldValid && validFields.has(name)) ||\r\n        (existFieldError && existFieldError.isManual)) {\r\n        return false;\r\n    }\r\n    if (isFormValid !== isFieldValid ||\r\n        (!isFormValid && !existFieldError) ||\r\n        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {\r\n        return true;\r\n    }\r\n    return currentFieldError && !isSameError(existFieldError, currentFieldError);\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => {\r\n    const isValueMessage = (value) => isObject(value) && !isRegex(value);\r\n    return isValueMessage(validationData)\r\n        ? validationData\r\n        : {\r\n            value: validationData,\r\n            message: '',\r\n        };\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value, name }, options, required, maxLength, minLength, min, max, pattern, validate, }) => {\r\n    var _a;\r\n    const fields = fieldsRef.current;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = isEmptyString(value);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n        if (!validateAllFieldCriteria) {\r\n            return error;\r\n        }\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value: requiredValue, message: requiredMessage } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (requiredValue) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxValue)) {\r\n                exceedMax = valueDate > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = valueDate < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\r\n        const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fields, ref);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner)\r\n    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (path\r\n        ? previous[path] && validateAllFieldCriteria\r\n            ? {\r\n                [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),\r\n            }\r\n            : {\r\n                [path]: previous[path] || Object.assign({ message,\r\n                    type }, (validateAllFieldCriteria\r\n                    ? {\r\n                        types: { [type]: message || true },\r\n                    }\r\n                    : {})),\r\n            }\r\n        : {}))), {})\r\n    : {\r\n        [error.path]: { message: error.message, type: error.type },\r\n    };\r\nasync function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context) {\r\n    if (validationResolver) {\r\n        return validationResolver(data, context);\r\n    }\r\n    try {\r\n        return {\r\n            values: await validationSchema.validate(data, {\r\n                abortEarly: false,\r\n                context,\r\n            }),\r\n            errors: {},\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            values: {},\r\n            errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria)),\r\n        };\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (value, key, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return isArray(values)\r\n        ? values.map((value, key) => getInnerPath(value, key))\r\n        : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));\r\n};\r\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else if (!isUndefined(fieldValues[fieldName])) {\r\n        value = fieldValues[fieldName];\r\n        watchFields.add(fieldName);\r\n    }\r\n    else {\r\n        value = get(transformToNestObject(fieldValues), fieldName);\r\n        if (!isUndefined(value)) {\r\n            getPath$1(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnChange, hasError, isBlurEvent, isOnSubmit, isReValidateOnSubmit, isOnBlur, isReValidateOnBlur, isSubmitted, }) => (isOnChange && isBlurEvent) ||\r\n    (isOnSubmit && isReValidateOnSubmit) ||\r\n    (isOnSubmit && !isSubmitted) ||\r\n    (isOnBlur && !isBlurEvent && !hasError) ||\r\n    (isReValidateOnBlur && !isBlurEvent && hasError) ||\r\n    (isReValidateOnSubmit && isSubmitted);\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nvar getFieldValueByName = (fields, name) => {\r\n    const results = transformToNestObject(getFieldsValues(fields));\r\n    return name ? get(results, name, results) : results;\r\n};\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\r\n    let isMatch = false;\r\n    if (!isArray(referenceArray) ||\r\n        !isArray(differenceArray) ||\r\n        referenceArray.length !== differenceArray.length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < referenceArray.length; i++) {\r\n        if (isMatch) {\r\n            break;\r\n        }\r\n        const dataA = referenceArray[i];\r\n        const dataB = differenceArray[i];\r\n        if (isUndefined(dataB) ||\r\n            Object.keys(dataA).length !== Object.keys(dataB).length) {\r\n            isMatch = true;\r\n            break;\r\n        }\r\n        for (const key in dataA) {\r\n            if (dataA[key] !== dataB[key]) {\r\n                isMatch = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return isMatch;\r\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, validationResolver, validationContext, defaultValues = {}, submitFocusError = true, validateCriteriaMode, } = {}) {\r\n    const fieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const errorsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const touchedFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const fieldArrayDefaultValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const watchFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const dirtyFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const fieldsWithValidationRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const validFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const isValidRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(true);\r\n    const defaultValuesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(defaultValues);\r\n    const defaultValuesAtRenderRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const isUnMount = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isWatchAllRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isSubmittedRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isDirtyRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const submitCountRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(0);\r\n    const isSubmittingRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const handleChangeRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\r\n    const resetFieldArrayFunctionRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const validationContextRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(validationContext);\r\n    const fieldArrayNamesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const [, render] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])();\r\n    const { isOnBlur, isOnSubmit, isOnChange } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(modeChecker(mode)).current;\r\n    const validateAllFieldCriteria = validateCriteriaMode === 'all';\r\n    const isWindowUndefined = typeof window === UNDEFINED;\r\n    const shouldValidateSchemaOrResolver = !!(validationSchema || validationResolver);\r\n    const isWeb = typeof document !== UNDEFINED &&\r\n        !isWindowUndefined &&\r\n        !isUndefined(window.HTMLElement);\r\n    const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\n    const readFormStateRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({\r\n        dirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        isSubmitted: isOnSubmit,\r\n        submitCount: !isProxyEnabled,\r\n        touched: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(modeChecker(reValidateMode)).current;\r\n    validationContextRef.current = validationContext;\r\n    const reRender = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(() => {\r\n        if (!isUnMount.current) {\r\n            render({});\r\n        }\r\n    }, []);\r\n    const shouldRenderBaseOnError = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, error, shouldRender = false) => {\r\n        let shouldReRender = shouldRender ||\r\n            shouldRenderBasedOnError({\r\n                errors: errorsRef.current,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        if (isEmptyObject(error)) {\r\n            if (fieldsWithValidationRef.current.has(name) ||\r\n                shouldValidateSchemaOrResolver) {\r\n                validFieldsRef.current.add(name);\r\n                shouldReRender = shouldReRender || get(errorsRef.current, name);\r\n            }\r\n            errorsRef.current = unset(errorsRef.current, [name]);\r\n        }\r\n        else {\r\n            const previousError = get(errorsRef.current, name);\r\n            validFieldsRef.current.delete(name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    (previousError\r\n                        ? !isSameError(previousError, error[name])\r\n                        : true);\r\n            set(errorsRef.current, name, error[name]);\r\n        }\r\n        if (shouldReRender && !isNullOrUndefined(shouldRender)) {\r\n            reRender();\r\n            return true;\r\n        }\r\n    }, [reRender, shouldValidateSchemaOrResolver]);\r\n    const setFieldValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, rawValue) => {\r\n        const { ref, options } = field;\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref)) {\r\n            if (isString(value)) {\r\n                ref.value = value;\r\n            }\r\n            else {\r\n                ref.files = value;\r\n            }\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = value.includes(checkboxRef.value)))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, [isWeb]);\r\n    const setDirty = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name) => {\r\n        if (!fieldsRef.current[name] ||\r\n            (!readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields)) {\r\n            return false;\r\n        }\r\n        let isFieldDirty = defaultValuesAtRenderRef.current[name] !==\r\n            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const previousDirtyFieldsLength = dirtyFieldsRef.current.size;\r\n        if (isFieldArray) {\r\n            const fieldArrayName = getFieldArrayParentName(name);\r\n            isFieldDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));\r\n        }\r\n        const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !==\r\n            isFieldDirty;\r\n        if (isFieldDirty) {\r\n            dirtyFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            dirtyFieldsRef.current.delete(name);\r\n        }\r\n        isDirtyRef.current = isFieldArray\r\n            ? isFieldDirty\r\n            : !!dirtyFieldsRef.current.size;\r\n        return readFormStateRef.current.dirty\r\n            ? isDirtyChanged\r\n            : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;\r\n    }, []);\r\n    const setInternalValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, value, parentFieldName) => {\r\n        const isValueArray = isArray(value);\r\n        for (const key in value) {\r\n            const fieldName = `${parentFieldName || name}${isValueArray ? `[${key}]` : `.${key}`}`;\r\n            const field = fieldsRef.current[fieldName];\r\n            if (isObject(value[key])) {\r\n                setInternalValues(name, value[key], fieldName);\r\n            }\r\n            if (field) {\r\n                setFieldValue(field, value[key]);\r\n                setDirty(fieldName);\r\n            }\r\n        }\r\n    }, [setFieldValue, setDirty]);\r\n    const setInternalValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, value) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            setFieldValue(field, value);\r\n            const output = setDirty(name);\r\n            if (isBoolean(output)) {\r\n                return output;\r\n            }\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value);\r\n        }\r\n    }, [setDirty, setFieldValue, setInternalValues]);\r\n    const executeValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (name, skipReRender) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            shouldRenderBaseOnError(name, error, skipReRender ? null : false);\r\n            return isEmptyObject(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, validateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (payload) => {\r\n        const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);\r\n        const previousFormIsValid = isValidRef.current;\r\n        isValidRef.current = isEmptyObject(errors);\r\n        if (isArray(payload)) {\r\n            payload.forEach((name) => {\r\n                const error = get(errors, name);\r\n                if (error) {\r\n                    set(errorsRef.current, name, error);\r\n                }\r\n                else {\r\n                    unset(errorsRef.current, [name]);\r\n                }\r\n            });\r\n            reRender();\r\n        }\r\n        else {\r\n            const error = get(errors, payload);\r\n            shouldRenderBaseOnError(payload, (error ? { [payload]: error } : {}), previousFormIsValid !== isValidRef.current);\r\n        }\r\n        return isEmptyObject(errorsRef.current);\r\n    }, [\r\n        reRender,\r\n        shouldRenderBaseOnError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const triggerValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (payload) => {\r\n        const fields = payload || Object.keys(fieldsRef.current);\r\n        if (shouldValidateSchemaOrResolver) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, true)));\r\n            reRender();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [\r\n        executeSchemaOrResolverValidation,\r\n        executeValidation,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n    ]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    function setValue(names, valueOrShouldValidate, shouldValidate) {\r\n        let shouldRender = false;\r\n        const isArrayValue = isArray(names);\r\n        (isArrayValue\r\n            ? names\r\n            : [names]).forEach((name) => {\r\n            const isStringFieldName = isString(name);\r\n            shouldRender =\r\n                setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName\r\n                    ? valueOrShouldValidate\r\n                    : Object.values(name)[0]) || isArrayValue\r\n                    ? true\r\n                    : isFieldWatched(name);\r\n        });\r\n        if (shouldRender || isArrayValue) {\r\n            reRender();\r\n        }\r\n        if (shouldValidate || (isArrayValue && valueOrShouldValidate)) {\r\n            triggerValidation(isArrayValue ? undefined : names);\r\n        }\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            const name = target ? target.name : '';\r\n            const fields = fieldsRef.current;\r\n            const errors = errorsRef.current;\r\n            const field = fields[name];\r\n            const currentError = get(errors, name);\r\n            let error;\r\n            if (!field) {\r\n                return;\r\n            }\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const shouldSkipValidation = skipValidation({\r\n                hasError: !!currentError,\r\n                isOnChange,\r\n                isBlurEvent,\r\n                isOnSubmit,\r\n                isReValidateOnSubmit,\r\n                isOnBlur,\r\n                isReValidateOnBlur,\r\n                isSubmitted: isSubmittedRef.current,\r\n            });\r\n            const shouldUpdateDirty = setDirty(name);\r\n            let shouldRender = isFieldWatched(name) || shouldUpdateDirty;\r\n            if (isBlurEvent &&\r\n                !get(touchedFieldsRef.current, name) &&\r\n                readFormStateRef.current.touched) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                shouldRender = true;\r\n            }\r\n            if (shouldSkipValidation) {\r\n                return shouldRender && reRender();\r\n            }\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);\r\n                const previousFormIsValid = isValidRef.current;\r\n                isValidRef.current = isEmptyObject(errors);\r\n                error = (get(errors, name)\r\n                    ? { [name]: get(errors, name) }\r\n                    : {});\r\n                if (previousFormIsValid !== isValidRef.current) {\r\n                    shouldRender = true;\r\n                }\r\n            }\r\n            else {\r\n                error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            }\r\n            if (!shouldRenderBaseOnError(name, error) && shouldRender) {\r\n                reRender();\r\n            }\r\n        };\r\n    const validateSchemaOrResolver = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((values = {}) => {\r\n        const fieldValues = isEmptyObject(defaultValuesRef.current)\r\n            ? getFieldsValues(fieldsRef.current)\r\n            : defaultValuesRef.current;\r\n        validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), validationResolver, validationContextRef.current).then(({ errors }) => {\r\n            const previousFormIsValid = isValidRef.current;\r\n            isValidRef.current = isEmptyObject(errors);\r\n            if (previousFormIsValid !== isValidRef.current) {\r\n                reRender();\r\n            }\r\n        });\r\n    }, \r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [reRender, validateAllFieldCriteria, validationResolver]);\r\n    const removeFieldEventListener = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, forceDelete) => {\r\n        if (handleChangeRef.current && field) {\r\n            findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, forceDelete) => {\r\n        if (!field ||\r\n            (field &&\r\n                isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) &&\r\n                !forceDelete)) {\r\n            return;\r\n        }\r\n        removeFieldEventListener(field, forceDelete);\r\n        const { name } = field.ref;\r\n        errorsRef.current = unset(errorsRef.current, [name]);\r\n        touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\r\n        defaultValuesAtRenderRef.current = unset(defaultValuesAtRenderRef.current, [name]);\r\n        [\r\n            dirtyFieldsRef,\r\n            fieldsWithValidationRef,\r\n            validFieldsRef,\r\n            watchFieldsRef,\r\n        ].forEach((data) => data.current.delete(name));\r\n        if (readFormStateRef.current.isValid ||\r\n            readFormStateRef.current.touched) {\r\n            reRender();\r\n            if (shouldValidateSchemaOrResolver) {\r\n                validateSchemaOrResolver();\r\n            }\r\n        }\r\n    }, [\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        validateSchemaOrResolver,\r\n        removeFieldEventListener,\r\n    ]);\r\n    function clearError(name) {\r\n        if (name) {\r\n            unset(errorsRef.current, isArray(name) ? name : [name]);\r\n        }\r\n        else {\r\n            errorsRef.current = {};\r\n        }\r\n        reRender();\r\n    }\r\n    const setInternalError = ({ name, type, types, message, shouldRender, }) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!isSameError(get(errorsRef.current, name), {\r\n            type,\r\n            message,\r\n            types,\r\n        })) {\r\n            set(errorsRef.current, name, {\r\n                type,\r\n                types,\r\n                message,\r\n                ref: field ? field.ref : {},\r\n                isManual: true,\r\n            });\r\n            if (shouldRender) {\r\n                reRender();\r\n            }\r\n        }\r\n    };\r\n    function setError(name, type = '', message) {\r\n        if (isString(name)) {\r\n            setInternalError(Object.assign(Object.assign({ name }, (isObject(type)\r\n                ? {\r\n                    types: type,\r\n                    type: '',\r\n                }\r\n                : {\r\n                    type,\r\n                    message,\r\n                })), { shouldRender: true }));\r\n        }\r\n        else if (isArray(name)) {\r\n            name.forEach((error) => setInternalError(Object.assign({}, error)));\r\n            reRender();\r\n        }\r\n    }\r\n    function watch(fieldNames, defaultValue) {\r\n        const watchFields = watchFieldsRef.current;\r\n        const isDefaultValueUndefined = isUndefined(defaultValue);\r\n        const combinedDefaultValues = isDefaultValueUndefined\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isDefaultValueUndefined\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = true;\r\n        const result = (!isEmptyObject(fieldValues) && fieldValues) || combinedDefaultValues;\r\n        return fieldNames && fieldNames.nest\r\n            ? transformToNestObject(result)\r\n            : result;\r\n    }\r\n    function unregister(name) {\r\n        if (fieldsRef.current) {\r\n            (isArray(name) ? name : [name]).forEach((fieldName) => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n        }\r\n    }\r\n    function registerFieldsRef(ref, validateOptions = {}) {\r\n        if (!ref.name) {\r\n            // eslint-disable-next-line no-console\r\n            return console.warn('Missing name @', ref);\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let isFieldArray;\r\n        let defaultValue;\r\n        if (isRadioOrCheckbox\r\n            ? field &&\r\n                isArray(field.options) &&\r\n                field.options.filter(Boolean).find((option) => {\r\n                    return value === option.ref.value && option.ref === ref;\r\n                })\r\n            : field && ref === field.ref) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), { mutationWatcher });\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        if (!isEmptyObject(defaultValuesRef.current)) {\r\n            defaultValue = get(defaultValuesRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(field, defaultValue);\r\n            }\r\n        }\r\n        if (shouldValidateSchemaOrResolver &&\r\n            !isFieldArray &&\r\n            readFormStateRef.current.isValid) {\r\n            validateSchemaOrResolver();\r\n        }\r\n        else if (!isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, validateAllFieldCriteria, field).then((error) => {\r\n                    const previousFormIsValid = isValidRef.current;\r\n                    isEmptyObject(error)\r\n                        ? validFieldsRef.current.add(name)\r\n                        : (isValidRef.current = false);\r\n                    if (previousFormIsValid !== isValidRef.current) {\r\n                        reRender();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, field.ref) : defaultValue;\r\n        }\r\n        if (type) {\r\n            attachEventListeners({\r\n                field: isRadioOrCheckbox && field.options\r\n                    ? field.options[field.options.length - 1]\r\n                    : field,\r\n                isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),\r\n                handleChange: handleChangeRef.current,\r\n            });\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, validationOptions) {\r\n        if (isWindowUndefined) {\r\n            return;\r\n        }\r\n        if (isString(refOrValidationOptions)) {\r\n            registerFieldsRef({ name: refOrValidationOptions }, validationOptions);\r\n            return;\r\n        }\r\n        if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\r\n            registerFieldsRef(refOrValidationOptions, validationOptions);\r\n            return;\r\n        }\r\n        return (ref) => ref && registerFieldsRef(ref, refOrValidationOptions);\r\n    }\r\n    const handleSubmit = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((callback) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        const fields = fieldsRef.current;\r\n        let fieldValues = getFieldsValues(fields);\r\n        if (readFormStateRef.current.isSubmitting) {\r\n            isSubmittingRef.current = true;\r\n            reRender();\r\n        }\r\n        try {\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors, values } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);\r\n                errorsRef.current = errors;\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fields)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            validFieldsRef.current.delete(name);\r\n                        }\r\n                        else {\r\n                            if (fieldsWithValidationRef.current.has(name)) {\r\n                                validFieldsRef.current.add(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors)) {\r\n                errorsRef.current = {};\r\n                reRender();\r\n                await callback(transformToNestObject(fieldValues), e);\r\n            }\r\n            else {\r\n                errorsRef.current = fieldErrors;\r\n                if (submitFocusError && isWeb) {\r\n                    focusOnErrorField(fields, fieldErrors);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            isSubmittedRef.current = true;\r\n            isSubmittingRef.current = false;\r\n            submitCountRef.current = submitCountRef.current + 1;\r\n            reRender();\r\n        }\r\n    }, [\r\n        isWeb,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        submitFocusError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const resetRefs = ({ errors, dirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        fieldsRef.current = {};\r\n        if (!errors) {\r\n            errorsRef.current = {};\r\n        }\r\n        if (!touched) {\r\n            touchedFieldsRef.current = {};\r\n        }\r\n        if (!isValid) {\r\n            validFieldsRef.current = new Set();\r\n            fieldsWithValidationRef.current = new Set();\r\n            isValidRef.current = true;\r\n        }\r\n        if (!dirty) {\r\n            isDirtyRef.current = false;\r\n        }\r\n        if (!dirtyFields) {\r\n            dirtyFieldsRef.current = new Set();\r\n        }\r\n        if (!isSubmitted) {\r\n            isSubmittedRef.current = false;\r\n        }\r\n        if (!submitCount) {\r\n            submitCountRef.current = 0;\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValues.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (values) {\r\n            defaultValuesRef.current = values;\r\n        }\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        resetRefs(omitResetState);\r\n        reRender();\r\n    };\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return fieldsRef.current[payload]\r\n                ? getFieldValue(fieldsRef.current, fieldsRef.current[payload].ref)\r\n                : get(defaultValuesRef.current, payload);\r\n        }\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const outputValues = isEmptyObject(fieldValues)\r\n            ? defaultValuesRef.current\r\n            : fieldValues;\r\n        return payload && payload.nest\r\n            ? transformToNestObject(outputValues)\r\n            : outputValues;\r\n    }\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => () => {\r\n        isUnMount.current = true;\r\n        fieldsRef.current &&\r\n            \"development\" === 'production' &&\r\n            Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, [removeFieldEventListenerAndRef]);\r\n    if (!shouldValidateSchemaOrResolver) {\r\n        isValidRef.current =\r\n            validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\r\n                isEmptyObject(errorsRef.current);\r\n    }\r\n    const formState = {\r\n        dirty: isDirtyRef.current,\r\n        dirtyFields: dirtyFieldsRef.current,\r\n        isSubmitted: isSubmittedRef.current,\r\n        submitCount: submitCountRef.current,\r\n        touched: touchedFieldsRef.current,\r\n        isSubmitting: isSubmittingRef.current,\r\n        isValid: isOnSubmit\r\n            ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\r\n            : isValidRef.current,\r\n    };\r\n    const commonProps = {\r\n        triggerValidation,\r\n        setValue: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(setValue, [\r\n            reRender,\r\n            setInternalValue,\r\n            triggerValidation,\r\n        ]),\r\n        register: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(register, [\r\n            defaultValuesRef.current,\r\n            defaultValuesAtRenderRef.current,\r\n        ]),\r\n        unregister: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(unregister, []),\r\n        getValues: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(getValues, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = Object.assign(Object.assign(Object.assign({ removeFieldEventListener,\r\n        reRender }, (shouldValidateSchemaOrResolver\r\n        ? { validateSchemaIsValid: validateSchemaOrResolver }\r\n        : {})), { mode: {\r\n            isOnBlur,\r\n            isOnSubmit,\r\n            isOnChange,\r\n        }, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnSubmit,\r\n        }, errorsRef,\r\n        touchedFieldsRef,\r\n        fieldsRef,\r\n        isWatchAllRef,\r\n        watchFieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        fieldArrayDefaultValues,\r\n        validFieldsRef,\r\n        dirtyFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        isDirtyRef,\r\n        readFormStateRef,\r\n        defaultValuesRef }), commonProps);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(reset, []), clearError: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(clearError, []), setError: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(setError, []), errors: errorsRef.current }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormGlobalContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"])(null);\r\nfunction useFormContext() {\r\n    return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormGlobalContext);\r\n}\r\nfunction FormContext(_a) {\r\n    var { children, formState, errors } = _a, restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\r\n    return (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restMethods), { formState, errors }) }, children));\r\n}\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst appendId = (value, keyName) => (Object.assign({ [keyName]: generateId() }, (isObject(value) ? value : { value })));\r\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n\nvar getSortRemovedItems = (indexes, removeIndexes, updatedIndexes = [], count = 0, notFoundIndexes = []) => {\r\n    for (const removeIndex of removeIndexes) {\r\n        if (indexes.indexOf(removeIndex) < 0) {\r\n            notFoundIndexes.push(removeIndex);\r\n        }\r\n    }\r\n    for (const index of indexes.sort()) {\r\n        if (removeIndexes.indexOf(index) > -1) {\r\n            updatedIndexes.push(-1);\r\n            count++;\r\n        }\r\n        else {\r\n            updatedIndexes.push(index -\r\n                count -\r\n                (notFoundIndexes.length\r\n                    ? notFoundIndexes\r\n                        .map((notFoundIndex) => notFoundIndex < index)\r\n                        .filter(Boolean).length\r\n                    : 0));\r\n        }\r\n    }\r\n    return updatedIndexes;\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return data.filter(Boolean);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(isArray(value) ? value : [value || null]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(isArray(value) ? value : [value || null]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => isArray(value) ? Array(value.length).fill(null) : null;\n\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    const { isWatchAllRef, resetFieldArrayFunctionRef, fieldArrayNamesRef, reRender, fieldsRef, getValues, defaultValuesRef, removeFieldEventListener, errorsRef, dirtyFieldsRef, isDirtyRef, touchedFieldsRef, readFormStateRef, watchFieldsRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValues, validateSchemaIsValid, } = control || methods.control;\r\n    const getDefaultValues = () => [\r\n        ...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)]\r\n            ? fieldArrayDefaultValues.current\r\n            : defaultValuesRef.current, name, []),\r\n    ];\r\n    const memoizedDefaultValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(getDefaultValues());\r\n    const [fields, setField] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(mapIds(memoizedDefaultValues.current, keyName));\r\n    const [isDeleted, setIsDeleted] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(false);\r\n    const allFields = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(fields);\r\n    const isNameKey = isKey(name);\r\n    allFields.current = fields;\r\n    if (isNameKey) {\r\n        fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\r\n    }\r\n    const appendValueWithKey = (values) => values.map((value) => appendId(value, keyName));\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setField(fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateSchemaIsValid) {\r\n            validateSchemaIsValid({\r\n                [name]: fieldsValues,\r\n            });\r\n        }\r\n    };\r\n    const modifyDirtyFields = ({ shouldRender, isRemove, isPrePend, index, value = {}, } = {}) => {\r\n        let render = shouldRender;\r\n        const values = isArray(value) ? value : [value];\r\n        if (readFormStateRef.current.dirty) {\r\n            const dirtyFieldIndexesAndValues = {};\r\n            if (isPrePend || isRemove) {\r\n                for (const dirtyField of [...dirtyFieldsRef.current].sort()) {\r\n                    if (isMatchFieldArrayName(dirtyField, name)) {\r\n                        const matchedIndexes = dirtyField.match(REGEX_ARRAY_FIELD_INDEX);\r\n                        if (matchedIndexes) {\r\n                            const matchIndex = +matchedIndexes[matchedIndexes.length - 1];\r\n                            if (dirtyFieldIndexesAndValues[matchIndex]) {\r\n                                dirtyFieldIndexesAndValues[matchIndex].push(dirtyField);\r\n                            }\r\n                            else {\r\n                                dirtyFieldIndexesAndValues[matchIndex] = [dirtyField];\r\n                            }\r\n                        }\r\n                        dirtyFieldsRef.current.delete(dirtyField);\r\n                    }\r\n                }\r\n            }\r\n            if (!isUndefined(index) || isPrePend) {\r\n                const updatedDirtyFieldIndexes = isUndefined(index)\r\n                    ? []\r\n                    : getSortRemovedItems(Object.keys(dirtyFieldIndexesAndValues).map((i) => +i), isArray(index) ? index : [index]);\r\n                Object.values(dirtyFieldIndexesAndValues).forEach((values, index) => {\r\n                    const updateIndex = isPrePend ? 0 : updatedDirtyFieldIndexes[index];\r\n                    if (updateIndex > -1) {\r\n                        for (const value of values) {\r\n                            const matchedIndexes = value.match(REGEX_ARRAY_FIELD_INDEX);\r\n                            if (matchedIndexes) {\r\n                                dirtyFieldsRef.current.add(value.replace(/[\\d+]([^[\\d+]+)$/, `${isPrePend\r\n                                    ? +matchedIndexes[matchedIndexes.length - 1] +\r\n                                        values.length\r\n                                    : updateIndex}$1`));\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if (!isRemove) {\r\n                values.forEach((fieldValue, index) => Object.keys(fieldValue).forEach((key) => dirtyFieldsRef.current.add(`${name}[${isPrePend ? index : allFields.current.length + index}].${key}`)));\r\n                isDirtyRef.current = true;\r\n            }\r\n            render = true;\r\n        }\r\n        if (render && !isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n    };\r\n    const resetFields = (flagOrFields) => {\r\n        if (readFormStateRef.current.dirty) {\r\n            isDirtyRef.current = isUndefined(flagOrFields)\r\n                ? true\r\n                : getIsFieldsDifferent(flagOrFields, defaultValuesRef.current[name] || []);\r\n        }\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n            }\r\n        }\r\n    };\r\n    const mapCurrentFieldsValueWithState = () => {\r\n        const currentFieldsValue = get(getValues({ nest: true }), name);\r\n        if (isArray(currentFieldsValue)) {\r\n            for (let i = 0; i < currentFieldsValue.length; i++) {\r\n                allFields.current[i] = Object.assign(Object.assign({}, allFields.current[i]), currentFieldsValue[i]);\r\n            }\r\n        }\r\n    };\r\n    const append = (value) => {\r\n        setFieldAndValidState([\r\n            ...allFields.current,\r\n            ...(isArray(value)\r\n                ? appendValueWithKey(value)\r\n                : [appendId(value, keyName)]),\r\n        ]);\r\n        modifyDirtyFields({ value });\r\n    };\r\n    const prepend$1 = (value) => {\r\n        let shouldRender = false;\r\n        resetFields();\r\n        setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = prepend(errorsRef.current[name], fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], fillEmptyArray(value));\r\n            shouldRender = true;\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isPrePend: true,\r\n            value,\r\n        });\r\n    };\r\n    const remove = (index) => {\r\n        let shouldRender = false;\r\n        const isIndexUndefined = isUndefined(index);\r\n        if (!isIndexUndefined) {\r\n            mapCurrentFieldsValueWithState();\r\n        }\r\n        resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(removeArrayAt(allFields.current, index));\r\n        setIsDeleted(true);\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = removeArrayAt(errorsRef.current[name], index);\r\n            if (!errorsRef.current[name].filter(Boolean).length) {\r\n                delete errorsRef.current[name];\r\n            }\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\r\n            shouldRender = true;\r\n        }\r\n        if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\r\n            let fieldIndex = -1;\r\n            let isFound = false;\r\n            const isIndexUndefined = isUndefined(index);\r\n            while (fieldIndex++ < fields.length) {\r\n                const isLast = fieldIndex === fields.length - 1;\r\n                const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\r\n                if (isCurrentIndex || isIndexUndefined) {\r\n                    isFound = true;\r\n                }\r\n                if (!isFound) {\r\n                    continue;\r\n                }\r\n                for (const key in fields[fieldIndex]) {\r\n                    const currentFieldName = `${name}[${fieldIndex}].${key}`;\r\n                    if (isCurrentIndex || isLast || isIndexUndefined) {\r\n                        validFieldsRef.current.delete(currentFieldName);\r\n                        fieldsWithValidationRef.current.delete(currentFieldName);\r\n                    }\r\n                    else {\r\n                        const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;\r\n                        if (validFieldsRef.current.has(currentFieldName)) {\r\n                            validFieldsRef.current.add(previousFieldName);\r\n                        }\r\n                        if (fieldsWithValidationRef.current.has(currentFieldName)) {\r\n                            fieldsWithValidationRef.current.add(previousFieldName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isRemove: true,\r\n            index,\r\n        });\r\n    };\r\n    const insert$1 = (index, value) => {\r\n        mapCurrentFieldsValueWithState();\r\n        resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = insert(errorsRef.current[name], index, fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, fillEmptyArray(value));\r\n            reRender();\r\n        }\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields(fieldValues);\r\n        swapArrayAt(allFields.current, indexA, indexB);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            swapArrayAt(errorsRef.current[name], indexA, indexB);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\r\n            reRender();\r\n        }\r\n    };\r\n    const move = (from, to) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields(fieldValues);\r\n        moveArrayAt(allFields.current, from, to);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            moveArrayAt(errorsRef.current[name], from, to);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            moveArrayAt(touchedFieldsRef.current[name], from, to);\r\n            reRender();\r\n        }\r\n    };\r\n    const reset = () => {\r\n        resetFields();\r\n        memoizedDefaultValues.current = getDefaultValues();\r\n        setField(mapIds(memoizedDefaultValues.current, keyName));\r\n    };\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (isNameKey &&\r\n            isDeleted &&\r\n            fieldArrayDefaultValues.current[name] &&\r\n            fields.length < fieldArrayDefaultValues.current[name].length) {\r\n            fieldArrayDefaultValues.current[name].pop();\r\n        }\r\n    }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (isWatchAllRef && isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    reRender();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }, [fields, name, reRender, watchFieldsRef, isWatchAllRef]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        fieldArrayNames.add(name);\r\n        resetFunctions[name] = reset;\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            fieldArrayNames.delete(name);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    return {\r\n        swap: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(swap, [name]),\r\n        move: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(move, [name]),\r\n        prepend: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(prepend$1, [name]),\r\n        append: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(append, [name]),\r\n        remove: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(remove, [fields, name]),\r\n        insert: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isCheckboxInput || isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as: InnerComponent, onBlur, onChange, onChangeName = VALIDATION_MODE.onChange, onBlurName = VALIDATION_MODE.onBlur, valueName, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onBlur\", \"onChange\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, setValue, register, unregister, errorsRef, removeFieldEventListener, triggerValidation, mode: { isOnSubmit, isOnBlur, isOnChange }, reValidateMode: { isReValidateOnBlur, isReValidateOnSubmit }, formState: { isSubmitted }, touchedFieldsRef, readFormStateRef, reRender, fieldsRef, fieldArrayNamesRef, } = control || methods.control;\r\n    const [value, setInputStateValue] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(isUndefined(defaultValue)\r\n        ? get(defaultValuesRef.current, name)\r\n        : defaultValue);\r\n    const valueRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(value);\r\n    const isCheckboxInput = isBoolean(value);\r\n    const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;\r\n    const rulesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(rules);\r\n    const onFocusRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(onFocus);\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    rulesRef.current = rules;\r\n    const shouldValidate = () => !skipValidation({\r\n        hasError: !!get(errorsRef.current, name),\r\n        isOnBlur,\r\n        isOnSubmit,\r\n        isOnChange,\r\n        isReValidateOnBlur,\r\n        isReValidateOnSubmit,\r\n        isSubmitted,\r\n    });\r\n    const commonTask = (event) => {\r\n        const data = getInputValue(event, isCheckboxInput);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    };\r\n    const eventWrapper = (event) => (...arg) => setValue(name, commonTask(event(arg)), shouldValidate());\r\n    const handleChange = (event) => {\r\n        const data = commonTask(event);\r\n        setValue(name, data, shouldValidate());\r\n    };\r\n    const registerField = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(() => {\r\n        if (!isNotFieldArray) {\r\n            removeFieldEventListener(fieldsRef.current[name], true);\r\n        }\r\n        register(Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\r\n            set(data) {\r\n                setInputStateValue(data);\r\n                valueRef.current = data;\r\n            },\r\n            get() {\r\n                return valueRef.current;\r\n            },\r\n        }), rulesRef.current);\r\n    }, [\r\n        isNotFieldArray,\r\n        fieldsRef,\r\n        rulesRef,\r\n        name,\r\n        onFocusRef,\r\n        register,\r\n        removeFieldEventListener,\r\n    ]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => () => {\r\n        !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\r\n    }, [unregister, name, fieldArrayNamesRef]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        registerField();\r\n    }, [registerField]);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (!fieldsRef.current[name]) {\r\n            registerField();\r\n            if (isNotFieldArray) {\r\n                setInputStateValue(isUndefined(defaultValue)\r\n                    ? get(defaultValuesRef.current, name)\r\n                    : defaultValue);\r\n            }\r\n        }\r\n    });\r\n    const props = Object.assign(Object.assign(Object.assign(Object.assign({ name }, rest), (onChange\r\n        ? { [onChangeName]: eventWrapper(onChange) }\r\n        : { [onChangeName]: handleChange })), { [onBlurName]: (...args) => {\r\n            if (onBlur) {\r\n                onBlur(args);\r\n            }\r\n            if (readFormStateRef.current.touched &&\r\n                !get(touchedFieldsRef.current, name)) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                reRender();\r\n            }\r\n            if (shouldReValidateOnBlur) {\r\n                triggerValidation(name);\r\n            }\r\n        } }), { [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value });\r\n    return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(InnerComponent)\r\n        ? Object(react__WEBPACK_IMPORTED_MODULE_0__[\"cloneElement\"])(InnerComponent, props)\r\n        : Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(InnerComponent, props);\r\n};\n\nconst ErrorMessage = (_a) => {\r\n    var { as: InnerComponent, errors, name, message, children } = _a, rest = __rest(_a, [\"as\", \"errors\", \"name\", \"message\", \"children\"]);\r\n    const methods = useFormContext();\r\n    const error = get(errors || methods.errors, name);\r\n    if (!error) {\r\n        return null;\r\n    }\r\n    const { message: messageFromRegister, types } = error;\r\n    const props = Object.assign(Object.assign({}, (InnerComponent ? rest : {})), { children: children\r\n            ? children({ message: messageFromRegister || message, messages: types })\r\n            : messageFromRegister || message });\r\n    return InnerComponent ? (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(InnerComponent) ? (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"cloneElement\"])(InnerComponent, props)) : (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(InnerComponent, props))) : (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(react__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], Object.assign({}, props)));\r\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvcmVhY3QtaG9vay1mb3JtLmVzLmpzPzMwNzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW1KOztBQUVuSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsU0FBUyxNQUFNLG9DQUFvQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWMsZUFBZTtBQUN0RSxDQUFDLElBQUk7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseURBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsSUFBSSx1REFBUztBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkVBQTJFLE9BQU87QUFDbEYsV0FBVztBQUNYLFdBQVcsK0JBQStCLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRSxJQUFJLDhEQUE4RDtBQUM3RSxXQUFXLDREQUFjO0FBQ3pCLFVBQVUsMERBQVk7QUFDdEIsVUFBVSwyREFBYTtBQUN2Qjs7QUFFQTtBQUNBLFNBQVMsc0RBQXNEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRCxnREFBZ0QsNkJBQTZCLEtBQUs7QUFDbEYsd0JBQXdCLDJEQUEyRDtBQUNuRiw4Q0FBOEM7QUFDOUMsNkJBQTZCLDREQUFjLG9CQUFvQiwwREFBWSw0QkFBNEIsMkRBQWEsNkJBQTZCLDJEQUFhLENBQUMsOENBQVEsa0JBQWtCO0FBQ3pMOztBQUV5RiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1ob29rLWZvcm0vZGlzdC9yZWFjdC1ob29rLWZvcm0uZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1ZhbGlkRWxlbWVudCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgY2xvbmVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0JztcblxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gKHZhbHVlKSA9PiB2YWx1ZSA9PSBudWxsO1xuXG52YXIgaXNBcnJheSA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cbmNvbnN0IGlzT2JqZWN0VHlwZSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcclxudmFyIGlzT2JqZWN0ID0gKHZhbHVlKSA9PiAhaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdFR5cGUodmFsdWUpO1xuXG52YXIgaXNIVE1MRWxlbWVudCA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcblxuY29uc3QgVkFMSURBVElPTl9NT0RFID0ge1xyXG4gICAgb25CbHVyOiAnb25CbHVyJyxcclxuICAgIG9uQ2hhbmdlOiAnb25DaGFuZ2UnLFxyXG4gICAgb25TdWJtaXQ6ICdvblN1Ym1pdCcsXHJcbn07XHJcbmNvbnN0IFZBTFVFID0gJ3ZhbHVlJztcclxuY29uc3QgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XHJcbmNvbnN0IEVWRU5UUyA9IHtcclxuICAgIEJMVVI6ICdibHVyJyxcclxuICAgIENIQU5HRTogJ2NoYW5nZScsXHJcbiAgICBJTlBVVDogJ2lucHV0JyxcclxufTtcclxuY29uc3QgU0VMRUNUID0gJ3NlbGVjdCc7XHJcbmNvbnN0IElOUFVUX1ZBTElEQVRJT05fUlVMRVMgPSB7XHJcbiAgICBtYXg6ICdtYXgnLFxyXG4gICAgbWluOiAnbWluJyxcclxuICAgIG1heExlbmd0aDogJ21heExlbmd0aCcsXHJcbiAgICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxyXG4gICAgcGF0dGVybjogJ3BhdHRlcm4nLFxyXG4gICAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXHJcbiAgICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJyxcclxufTtcclxuY29uc3QgUkVHRVhfSVNfREVFUF9QUk9QID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLztcclxuY29uc3QgUkVHRVhfSVNfUExBSU5fUFJPUCA9IC9eXFx3KiQvO1xyXG5jb25zdCBSRUdFWF9QUk9QX05BTUUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XHJcbmNvbnN0IFJFR0VYX0VTQ0FQRV9DSEFSID0gL1xcXFwoXFxcXCk/L2c7XHJcbmNvbnN0IFJFR0VYX0FSUkFZX0ZJRUxEX0lOREVYID0gL1tcXGQrXS9nO1xuXG5mdW5jdGlvbiBhdHRhY2hFdmVudExpc3RlbmVycyh7IGZpZWxkOiB7IHJlZiB9LCBoYW5kbGVDaGFuZ2UsIGlzUmFkaW9PckNoZWNrYm94LCB9KSB7XHJcbiAgICBpZiAoaXNIVE1MRWxlbWVudChyZWYpICYmIGhhbmRsZUNoYW5nZSkge1xyXG4gICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKGlzUmFkaW9PckNoZWNrYm94ID8gRVZFTlRTLkNIQU5HRSA6IEVWRU5UUy5JTlBVVCwgaGFuZGxlQ2hhbmdlKTtcclxuICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMuQkxVUiwgaGFuZGxlQ2hhbmdlKTtcclxuICAgIH1cclxufVxuXG52YXIgaXNLZXkgPSAodmFsdWUpID0+ICFpc0FycmF5KHZhbHVlKSAmJlxyXG4gICAgKFJFR0VYX0lTX1BMQUlOX1BST1AudGVzdCh2YWx1ZSkgfHwgIVJFR0VYX0lTX0RFRVBfUFJPUC50ZXN0KHZhbHVlKSk7XG5cbnZhciBzdHJpbmdUb1BhdGggPSAoc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIHN0cmluZy5yZXBsYWNlKFJFR0VYX1BST1BfTkFNRSwgKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpID0+IHtcclxuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKFJFR0VYX0VTQ0FQRV9DSEFSLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XG5cbmZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XHJcbiAgICBsZXQgaW5kZXggPSAtMTtcclxuICAgIGNvbnN0IHRlbXBQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCk7XHJcbiAgICBjb25zdCBsZW5ndGggPSB0ZW1wUGF0aC5sZW5ndGg7XHJcbiAgICBjb25zdCBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0ZW1wUGF0aFtpbmRleF07XHJcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSBsYXN0SW5kZXgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcclxuICAgICAgICAgICAgbmV3VmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzQXJyYXkob2JqVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogIWlzTmFOKCt0ZW1wUGF0aFtpbmRleCArIDFdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XHJcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqZWN0O1xyXG59XG5cbnZhciB0cmFuc2Zvcm1Ub05lc3RPYmplY3QgPSAoZGF0YSkgPT4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChwcmV2aW91cywgW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICBpZiAoIWlzS2V5KGtleSkpIHtcclxuICAgICAgICBzZXQocHJldmlvdXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBwcmV2aW91cztcclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXZpb3VzKSwgeyBba2V5XTogdmFsdWUgfSk7XHJcbn0sIHt9KTtcblxudmFyIGlzVW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsID09PSB1bmRlZmluZWQ7XG5cbnZhciBnZXQgPSAob2JqLCBwYXRoLCBkZWZhdWx0VmFsdWUpID0+IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHBhdGhcclxuICAgICAgICAuc3BsaXQoL1ssW1xcXS5dKz8vKVxyXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcclxuICAgICAgICAucmVkdWNlKChyZXN1bHQsIGtleSkgPT4gKGlzTnVsbE9yVW5kZWZpbmVkKHJlc3VsdCkgPyByZXN1bHQgOiByZXN1bHRba2V5XSksIG9iaik7XHJcbiAgICByZXR1cm4gaXNVbmRlZmluZWQocmVzdWx0KSB8fCByZXN1bHQgPT09IG9ialxyXG4gICAgICAgID8gaXNVbmRlZmluZWQob2JqW3BhdGhdKVxyXG4gICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZVxyXG4gICAgICAgICAgICA6IG9ialtwYXRoXVxyXG4gICAgICAgIDogcmVzdWx0O1xyXG59O1xuXG52YXIgZm9jdXNPbkVycm9yRmllbGQgPSAoZmllbGRzLCBmaWVsZEVycm9ycykgPT4ge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzKSB7XHJcbiAgICAgICAgaWYgKGdldChmaWVsZEVycm9ycywga2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZWYuZm9jdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5yZWYuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5vcHRpb25zWzBdLnJlZi5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuXG52YXIgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSAocmVmLCB2YWxpZGF0ZVdpdGhTdGF0ZVVwZGF0ZSkgPT4ge1xyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQocmVmKSAmJiByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUy5JTlBVVCwgdmFsaWRhdGVXaXRoU3RhdGVVcGRhdGUpO1xyXG4gICAgICAgIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUy5DSEFOR0UsIHZhbGlkYXRlV2l0aFN0YXRlVXBkYXRlKTtcclxuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuQkxVUiwgdmFsaWRhdGVXaXRoU3RhdGVVcGRhdGUpO1xyXG4gICAgfVxyXG59O1xuXG52YXIgaXNSYWRpb0lucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJztcblxudmFyIGlzQ2hlY2tCb3hJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdjaGVja2JveCc7XG5cbmZ1bmN0aW9uIGlzRGV0YWNoZWQoZWxlbWVudCkge1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8XHJcbiAgICAgICAgZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzRGV0YWNoZWQoZWxlbWVudC5wYXJlbnROb2RlKTtcclxufVxuXG52YXIgaXNFbXB0eU9iamVjdCA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBzdHJpbmdUb1BhdGgodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XHJcbiAgICBjb25zdCB1cGRhdGVQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcclxuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIG9iamVjdCA9IGlzVW5kZWZpbmVkKG9iamVjdCkgPyBpbmRleCsrIDogb2JqZWN0W3VwZGF0ZVBhdGhbaW5kZXgrK11dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZGV4ID09IGxlbmd0aCA/IG9iamVjdCA6IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcclxuICAgIGxldCBpbmRleCA9IC0xO1xyXG4gICAgbGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuICAgIGlmIChzdGFydCA8IDApIHtcclxuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiBsZW5ndGggKyBzdGFydDtcclxuICAgIH1cclxuICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcclxuICAgIGlmIChlbmQgPCAwKSB7XHJcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcclxuICAgIH1cclxuICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6IGVuZCAtIHN0YXJ0O1xyXG4gICAgY29uc3QgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcclxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcclxufVxyXG5mdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XHJcbiAgICBjb25zdCB1cGRhdGVQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcclxuICAgIGNvbnN0IGNoaWxkT2JqZWN0ID0gcGFyZW50KG9iamVjdCwgdXBkYXRlUGF0aCk7XHJcbiAgICBjb25zdCBrZXkgPSB1cGRhdGVQYXRoW3VwZGF0ZVBhdGgubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCByZXN1bHQgPSAhKGNoaWxkT2JqZWN0ICE9IG51bGwpIHx8IGRlbGV0ZSBjaGlsZE9iamVjdFtrZXldO1xyXG4gICAgbGV0IHByZXZpb3VzT2JqUmVmID0gdW5kZWZpbmVkO1xyXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCB1cGRhdGVQYXRoLnNsaWNlKDAsIC0xKS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xyXG4gICAgICAgIGxldCBvYmplY3RSZWYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGhzID0gdXBkYXRlUGF0aC5zbGljZSgwLCAtKGsgKyAxKSk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGhzTGVuZ3RoID0gY3VycmVudFBhdGhzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgaWYgKGsgPiAwKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzT2JqUmVmID0gb2JqZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGN1cnJlbnRQYXRocy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGN1cnJlbnRQYXRoc1tpbmRleF07XHJcbiAgICAgICAgICAgIG9iamVjdFJlZiA9IG9iamVjdFJlZiA/IG9iamVjdFJlZltpdGVtXSA6IG9iamVjdFtpdGVtXTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXRoc0xlbmd0aCA9PT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoaXNPYmplY3Qob2JqZWN0UmVmKSAmJiBpc0VtcHR5T2JqZWN0KG9iamVjdFJlZikpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGlzQXJyYXkob2JqZWN0UmVmKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhb2JqZWN0UmVmLmZpbHRlcigoZGF0YSkgPT4gaXNPYmplY3QoZGF0YSkgJiYgIWlzRW1wdHlPYmplY3QoZGF0YSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzT2JqUmVmID8gZGVsZXRlIHByZXZpb3VzT2JqUmVmW2l0ZW1dIDogZGVsZXRlIG9iamVjdFtpdGVtXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcmV2aW91c09ialJlZiA9IG9iamVjdFJlZjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aHMpIHtcclxuICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcclxuICAgICAgICBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9iamVjdDtcclxufVxuXG5jb25zdCBpc1NhbWVSZWYgPSAoZmllbGRWYWx1ZSwgcmVmKSA9PiBmaWVsZFZhbHVlICYmIGZpZWxkVmFsdWUucmVmID09PSByZWY7XHJcbmZ1bmN0aW9uIGZpbmRSZW1vdmVkRmllbGRBbmRSZW1vdmVMaXN0ZW5lcihmaWVsZHMsIGhhbmRsZUNoYW5nZSwgZmllbGQsIGZvcmNlRGVsZXRlKSB7XHJcbiAgICBjb25zdCB7IHJlZiwgcmVmOiB7IG5hbWUsIHR5cGUgfSwgbXV0YXRpb25XYXRjaGVyLCB9ID0gZmllbGQ7XHJcbiAgICBjb25zdCBmaWVsZFZhbHVlID0gZmllbGRzW25hbWVdO1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgZGVsZXRlIGZpZWxkc1tuYW1lXTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoKGlzUmFkaW9JbnB1dChyZWYpIHx8IGlzQ2hlY2tCb3hJbnB1dChyZWYpKSAmJiBmaWVsZFZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBmaWVsZFZhbHVlO1xyXG4gICAgICAgIGlmIChpc0FycmF5KG9wdGlvbnMpICYmIG9wdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKG9wdGlvbiwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVmLCBtdXRhdGlvbldhdGNoZXIgfSA9IG9wdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICgocmVmICYmIGlzRGV0YWNoZWQocmVmKSAmJiBpc1NhbWVSZWYob3B0aW9uLCByZWYpKSB8fCBmb3JjZURlbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKHJlZiwgaGFuZGxlQ2hhbmdlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25XYXRjaGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uV2F0Y2hlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHVuc2V0KG9wdGlvbnMsIFtgWyR7aW5kZXh9XWBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmICFvcHRpb25zLmZpbHRlcihCb29sZWFuKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKGlzRGV0YWNoZWQocmVmKSAmJiBpc1NhbWVSZWYoZmllbGRWYWx1ZSwgcmVmKSkgfHwgZm9yY2VEZWxldGUpIHtcclxuICAgICAgICByZW1vdmVBbGxFdmVudExpc3RlbmVycyhyZWYsIGhhbmRsZUNoYW5nZSk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uV2F0Y2hlcikge1xyXG4gICAgICAgICAgICBtdXRhdGlvbldhdGNoZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgZmllbGRzW25hbWVdO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGRlZmF1bHRSZXR1cm4gPSB7XHJcbiAgICBpc1ZhbGlkOiBmYWxzZSxcclxuICAgIHZhbHVlOiAnJyxcclxufTtcclxudmFyIGdldFJhZGlvVmFsdWUgPSAob3B0aW9ucykgPT4gaXNBcnJheShvcHRpb25zKVxyXG4gICAgPyBvcHRpb25zLnJlZHVjZSgocHJldmlvdXMsIG9wdGlvbikgPT4gb3B0aW9uICYmIG9wdGlvbi5yZWYuY2hlY2tlZFxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnJlZi52YWx1ZSxcclxuICAgICAgICB9XHJcbiAgICAgICAgOiBwcmV2aW91cywgZGVmYXVsdFJldHVybilcclxuICAgIDogZGVmYXVsdFJldHVybjtcblxudmFyIGdldE11bHRpcGxlU2VsZWN0VmFsdWUgPSAob3B0aW9ucykgPT4gWy4uLm9wdGlvbnNdXHJcbiAgICAuZmlsdGVyKCh7IHNlbGVjdGVkIH0pID0+IHNlbGVjdGVkKVxyXG4gICAgLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG5cbnZhciBpc0ZpbGVJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdmaWxlJztcblxudmFyIGlzTXVsdGlwbGVTZWxlY3QgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSBgJHtTRUxFQ1R9LW11bHRpcGxlYDtcblxudmFyIGlzRW1wdHlTdHJpbmcgPSAodmFsdWUpID0+IHZhbHVlID09PSAnJztcblxuY29uc3QgZGVmYXVsdFJlc3VsdCA9IHtcclxuICAgIHZhbHVlOiBmYWxzZSxcclxuICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG59O1xyXG5jb25zdCB2YWxpZFJlc3VsdCA9IHsgdmFsdWU6IHRydWUsIGlzVmFsaWQ6IHRydWUgfTtcclxudmFyIGdldENoZWNrYm94VmFsdWUgPSAob3B0aW9ucykgPT4ge1xyXG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucykpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdGlvbnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG9wdGlvbikgPT4gb3B0aW9uICYmIG9wdGlvbi5yZWYuY2hlY2tlZClcclxuICAgICAgICAgICAgICAgIC5tYXAoKHsgcmVmOiB7IHZhbHVlIH0gfSkgPT4gdmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWVzLCBpc1ZhbGlkOiAhIXZhbHVlcy5sZW5ndGggfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBjaGVja2VkLCB2YWx1ZSwgYXR0cmlidXRlcyB9ID0gb3B0aW9uc1swXS5yZWY7XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrZWRcclxuICAgICAgICAgICAgPyBhdHRyaWJ1dGVzICYmICFpc1VuZGVmaW5lZChhdHRyaWJ1dGVzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgPyBpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgaXNFbXB0eVN0cmluZyh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICA/IHZhbGlkUmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7IHZhbHVlOiB2YWx1ZSwgaXNWYWxpZDogdHJ1ZSB9XHJcbiAgICAgICAgICAgICAgICA6IHZhbGlkUmVzdWx0XHJcbiAgICAgICAgICAgIDogZGVmYXVsdFJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xyXG59O1xuXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKGZpZWxkcywgcmVmKSB7XHJcbiAgICBjb25zdCB7IG5hbWUsIHZhbHVlIH0gPSByZWY7XHJcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcclxuICAgIGlmIChpc0ZpbGVJbnB1dChyZWYpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlcztcclxuICAgIH1cclxuICAgIGlmIChpc1JhZGlvSW5wdXQocmVmKSkge1xyXG4gICAgICAgIHJldHVybiBmaWVsZCA/IGdldFJhZGlvVmFsdWUoZmllbGQub3B0aW9ucykudmFsdWUgOiAnJztcclxuICAgIH1cclxuICAgIGlmIChpc011bHRpcGxlU2VsZWN0KHJlZikpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TXVsdGlwbGVTZWxlY3RWYWx1ZShyZWYub3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNDaGVja0JveElucHV0KHJlZikpIHtcclxuICAgICAgICByZXR1cm4gZmllbGQgPyBnZXRDaGVja2JveFZhbHVlKGZpZWxkLm9wdGlvbnMpLnZhbHVlIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxudmFyIGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG52YXIgZ2V0RmllbGRzVmFsdWVzID0gKGZpZWxkcywgc2VhcmNoKSA9PiB7XHJcbiAgICBjb25zdCBvdXRwdXQgPSB7fTtcclxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBmaWVsZHMpIHtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2VhcmNoKSB8fFxyXG4gICAgICAgICAgICAoaXNTdHJpbmcoc2VhcmNoKVxyXG4gICAgICAgICAgICAgICAgPyBuYW1lLnN0YXJ0c1dpdGgoc2VhcmNoKVxyXG4gICAgICAgICAgICAgICAgOiBpc0FycmF5KHNlYXJjaClcclxuICAgICAgICAgICAgICAgICAgICA/IHNlYXJjaC5maW5kKChkYXRhKSA9PiBuYW1lLnN0YXJ0c1dpdGgoZGF0YSkpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBzZWFyY2ggJiYgc2VhcmNoLm5lc3QpKSB7XHJcbiAgICAgICAgICAgIG91dHB1dFtuYW1lXSA9IGdldEZpZWxkVmFsdWUoZmllbGRzLCBmaWVsZHNbbmFtZV0ucmVmKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xuXG52YXIgY29tcGFyZU9iamVjdCA9IChvYmplY3RBID0ge30sIG9iamVjdEIgPSB7fSkgPT4ge1xyXG4gICAgY29uc3Qgb2JqZWN0QUtleXMgPSBPYmplY3Qua2V5cyhvYmplY3RBKTtcclxuICAgIGNvbnN0IG9iamVjdEJLZXlzID0gT2JqZWN0LmtleXMob2JqZWN0Qik7XHJcbiAgICByZXR1cm4gKG9iamVjdEFLZXlzLmxlbmd0aCA9PT0gb2JqZWN0QktleXMubGVuZ3RoICYmXHJcbiAgICAgICAgb2JqZWN0QUtleXMuZXZlcnkoKGtleSkgPT4gb2JqZWN0QltrZXldICYmIG9iamVjdEJba2V5XSA9PT0gb2JqZWN0QVtrZXldKSk7XHJcbn07XG5cbnZhciBpc1NhbWVFcnJvciA9IChlcnJvciwgeyB0eXBlLCB0eXBlcywgbWVzc2FnZSB9KSA9PiBpc09iamVjdChlcnJvcikgJiZcclxuICAgIGVycm9yLnR5cGUgPT09IHR5cGUgJiZcclxuICAgIGVycm9yLm1lc3NhZ2UgPT09IG1lc3NhZ2UgJiZcclxuICAgIGNvbXBhcmVPYmplY3QoZXJyb3IudHlwZXMsIHR5cGVzKTtcblxuZnVuY3Rpb24gc2hvdWxkUmVuZGVyQmFzZWRPbkVycm9yKHsgZXJyb3JzLCBuYW1lLCBlcnJvciwgdmFsaWRGaWVsZHMsIGZpZWxkc1dpdGhWYWxpZGF0aW9uLCB9KSB7XHJcbiAgICBjb25zdCBpc0ZpZWxkVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9yKTtcclxuICAgIGNvbnN0IGlzRm9ybVZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xyXG4gICAgY29uc3QgY3VycmVudEZpZWxkRXJyb3IgPSBnZXQoZXJyb3IsIG5hbWUpO1xyXG4gICAgY29uc3QgZXhpc3RGaWVsZEVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XHJcbiAgICBpZiAoKGlzRmllbGRWYWxpZCAmJiB2YWxpZEZpZWxkcy5oYXMobmFtZSkpIHx8XHJcbiAgICAgICAgKGV4aXN0RmllbGRFcnJvciAmJiBleGlzdEZpZWxkRXJyb3IuaXNNYW51YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRm9ybVZhbGlkICE9PSBpc0ZpZWxkVmFsaWQgfHxcclxuICAgICAgICAoIWlzRm9ybVZhbGlkICYmICFleGlzdEZpZWxkRXJyb3IpIHx8XHJcbiAgICAgICAgKGlzRmllbGRWYWxpZCAmJiBmaWVsZHNXaXRoVmFsaWRhdGlvbi5oYXMobmFtZSkgJiYgIXZhbGlkRmllbGRzLmhhcyhuYW1lKSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBjdXJyZW50RmllbGRFcnJvciAmJiAhaXNTYW1lRXJyb3IoZXhpc3RGaWVsZEVycm9yLCBjdXJyZW50RmllbGRFcnJvcik7XHJcbn1cblxudmFyIGlzUmVnZXggPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuXG52YXIgZ2V0VmFsdWVBbmRNZXNzYWdlID0gKHZhbGlkYXRpb25EYXRhKSA9PiB7XHJcbiAgICBjb25zdCBpc1ZhbHVlTWVzc2FnZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmICFpc1JlZ2V4KHZhbHVlKTtcclxuICAgIHJldHVybiBpc1ZhbHVlTWVzc2FnZSh2YWxpZGF0aW9uRGF0YSlcclxuICAgICAgICA/IHZhbGlkYXRpb25EYXRhXHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWxpZGF0aW9uRGF0YSxcclxuICAgICAgICAgICAgbWVzc2FnZTogJycsXHJcbiAgICAgICAgfTtcclxufTtcblxudmFyIGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzQm9vbGVhbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG5cbnZhciBpc01lc3NhZ2UgPSAodmFsdWUpID0+IGlzU3RyaW5nKHZhbHVlKSB8fCAoaXNPYmplY3QodmFsdWUpICYmIGlzVmFsaWRFbGVtZW50KHZhbHVlKSk7XG5cbmZ1bmN0aW9uIGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCByZWYsIHR5cGUgPSAndmFsaWRhdGUnKSB7XHJcbiAgICBpZiAoaXNNZXNzYWdlKHJlc3VsdCkgfHwgKGlzQm9vbGVhbihyZXN1bHQpICYmICFyZXN1bHQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogaXNNZXNzYWdlKHJlc3VsdCkgPyByZXN1bHQgOiAnJyxcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxudmFyIGFwcGVuZEVycm9ycyA9IChuYW1lLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGVycm9ycywgdHlwZSwgbWVzc2FnZSkgPT4ge1xyXG4gICAgaWYgKHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JzW25hbWVdO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVycm9yKSwgeyB0eXBlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoZXJyb3IgJiYgZXJyb3IudHlwZXMgPyBlcnJvci50eXBlcyA6IHt9KSksIHsgW3R5cGVdOiBtZXNzYWdlIHx8IHRydWUgfSkgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge307XHJcbn07XG5cbnZhciB2YWxpZGF0ZUZpZWxkID0gYXN5bmMgKGZpZWxkc1JlZiwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCB7IHJlZiwgcmVmOiB7IHR5cGUsIHZhbHVlLCBuYW1lIH0sIG9wdGlvbnMsIHJlcXVpcmVkLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCwgbWluLCBtYXgsIHBhdHRlcm4sIHZhbGlkYXRlLCB9KSA9PiB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBmaWVsZHMgPSBmaWVsZHNSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGVycm9yID0ge307XHJcbiAgICBjb25zdCBpc1JhZGlvID0gaXNSYWRpb0lucHV0KHJlZik7XHJcbiAgICBjb25zdCBpc0NoZWNrQm94ID0gaXNDaGVja0JveElucHV0KHJlZik7XHJcbiAgICBjb25zdCBpc1JhZGlvT3JDaGVja2JveCA9IGlzUmFkaW8gfHwgaXNDaGVja0JveDtcclxuICAgIGNvbnN0IGlzRW1wdHkgPSBpc0VtcHR5U3RyaW5nKHZhbHVlKTtcclxuICAgIGNvbnN0IGFwcGVuZEVycm9yc0N1cnJ5ID0gYXBwZW5kRXJyb3JzLmJpbmQobnVsbCwgbmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcik7XHJcbiAgICBjb25zdCBnZXRNaW5NYXhNZXNzYWdlID0gKGV4Y2VlZE1heCwgbWF4TGVuZ3RoTWVzc2FnZSwgbWluTGVuZ3RoTWVzc2FnZSwgbWF4VHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWF4TGVuZ3RoLCBtaW5UeXBlID0gSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW5MZW5ndGgpID0+IHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXhjZWVkTWF4ID8gbWF4TGVuZ3RoTWVzc2FnZSA6IG1pbkxlbmd0aE1lc3NhZ2U7XHJcbiAgICAgICAgZXJyb3JbbmFtZV0gPSBPYmplY3QuYXNzaWduKHsgdHlwZTogZXhjZWVkTWF4ID8gbWF4VHlwZSA6IG1pblR5cGUsIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgIHJlZiB9LCAoZXhjZWVkTWF4XHJcbiAgICAgICAgICAgID8gYXBwZW5kRXJyb3JzQ3VycnkobWF4VHlwZSwgbWVzc2FnZSlcclxuICAgICAgICAgICAgOiBhcHBlbmRFcnJvcnNDdXJyeShtaW5UeXBlLCBtZXNzYWdlKSkpO1xyXG4gICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKHJlcXVpcmVkICYmXHJcbiAgICAgICAgKCghaXNSYWRpbyAmJiAhaXNDaGVja0JveCAmJiAoaXNFbXB0eSB8fCBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpKSB8fFxyXG4gICAgICAgICAgICAoaXNCb29sZWFuKHZhbHVlKSAmJiAhdmFsdWUpIHx8XHJcbiAgICAgICAgICAgIChpc0NoZWNrQm94ICYmICFnZXRDaGVja2JveFZhbHVlKG9wdGlvbnMpLmlzVmFsaWQpIHx8XHJcbiAgICAgICAgICAgIChpc1JhZGlvICYmICFnZXRSYWRpb1ZhbHVlKG9wdGlvbnMpLmlzVmFsaWQpKSkge1xyXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IHJlcXVpcmVkVmFsdWUsIG1lc3NhZ2U6IHJlcXVpcmVkTWVzc2FnZSB9ID0gaXNNZXNzYWdlKHJlcXVpcmVkKVxyXG4gICAgICAgICAgICA/IHsgdmFsdWU6ICEhcmVxdWlyZWQsIG1lc3NhZ2U6IHJlcXVpcmVkIH1cclxuICAgICAgICAgICAgOiBnZXRWYWx1ZUFuZE1lc3NhZ2UocmVxdWlyZWQpO1xyXG4gICAgICAgIGlmIChyZXF1aXJlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbih7IHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsIG1lc3NhZ2U6IHJlcXVpcmVkTWVzc2FnZSwgcmVmOiBpc1JhZGlvT3JDaGVja2JveCA/IChfYSA9IGZpZWxkc1tuYW1lXS5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0ucmVmIDogcmVmIH0sIGFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsIHJlcXVpcmVkTWVzc2FnZSkpO1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtaW4pIHx8ICFpc051bGxPclVuZGVmaW5lZChtYXgpKSB7XHJcbiAgICAgICAgbGV0IGV4Y2VlZE1heDtcclxuICAgICAgICBsZXQgZXhjZWVkTWluO1xyXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IG1heFZhbHVlLCBtZXNzYWdlOiBtYXhNZXNzYWdlIH0gPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWF4KTtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBtaW5WYWx1ZSwgbWVzc2FnZTogbWluTWVzc2FnZSB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbik7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8ICghdHlwZSAmJiAhaXNOYU4odmFsdWUpKSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU51bWJlciA9IHJlZi52YWx1ZUFzTnVtYmVyIHx8IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1heFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gdmFsdWVOdW1iZXIgPiBtYXhWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1pblZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gdmFsdWVOdW1iZXIgPCBtaW5WYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRlID0gcmVmLnZhbHVlQXNEYXRlIHx8IG5ldyBEYXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1heFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gdmFsdWVEYXRlID4gbmV3IERhdGUobWF4VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtaW5WYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IHZhbHVlRGF0ZSA8IG5ldyBEYXRlKG1pblZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xyXG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKCEhZXhjZWVkTWF4LCBtYXhNZXNzYWdlLCBtaW5NZXNzYWdlLCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heCwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW4pO1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNFbXB0eSAmJiAobWF4TGVuZ3RoIHx8IG1pbkxlbmd0aCkpIHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBtYXhMZW5ndGhWYWx1ZSwgbWVzc2FnZTogbWF4TGVuZ3RoTWVzc2FnZSwgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXhMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IG1pbkxlbmd0aFZhbHVlLCBtZXNzYWdlOiBtaW5MZW5ndGhNZXNzYWdlLCB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbkxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgaW5wdXRMZW5ndGggPSB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBleGNlZWRNYXggPSAhaXNOdWxsT3JVbmRlZmluZWQobWF4TGVuZ3RoVmFsdWUpICYmIGlucHV0TGVuZ3RoID4gbWF4TGVuZ3RoVmFsdWU7XHJcbiAgICAgICAgY29uc3QgZXhjZWVkTWluID0gIWlzTnVsbE9yVW5kZWZpbmVkKG1pbkxlbmd0aFZhbHVlKSAmJiBpbnB1dExlbmd0aCA8IG1pbkxlbmd0aFZhbHVlO1xyXG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XHJcbiAgICAgICAgICAgIGdldE1pbk1heE1lc3NhZ2UoISFleGNlZWRNYXgsIG1heExlbmd0aE1lc3NhZ2UsIG1pbkxlbmd0aE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhdHRlcm4gJiYgIWlzRW1wdHkpIHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBwYXR0ZXJuVmFsdWUsIG1lc3NhZ2U6IHBhdHRlcm5NZXNzYWdlIH0gPSBnZXRWYWx1ZUFuZE1lc3NhZ2UocGF0dGVybik7XHJcbiAgICAgICAgaWYgKGlzUmVnZXgocGF0dGVyblZhbHVlKSAmJiAhcGF0dGVyblZhbHVlLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbih7IHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucGF0dGVybiwgbWVzc2FnZTogcGF0dGVybk1lc3NhZ2UsIHJlZiB9LCBhcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sIHBhdHRlcm5NZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodmFsaWRhdGUpIHtcclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZ2V0RmllbGRWYWx1ZShmaWVsZHMsIHJlZik7XHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGVSZWYgPSBpc1JhZGlvT3JDaGVja2JveCAmJiBvcHRpb25zID8gb3B0aW9uc1swXS5yZWYgOiByZWY7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdGUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlKGZpZWxkVmFsdWUpO1xyXG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIHZhbGlkYXRlUmVmKTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWxpZGF0ZUVycm9yKSwgYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy52YWxpZGF0ZSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWxpZGF0ZSkpIHtcclxuICAgICAgICAgICAgbGV0IHZhbGlkYXRpb25SZXN1bHQgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxpZGF0ZUZ1bmN0aW9uXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSAmJiAhdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZVJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlRnVuY3Rpb24oZmllbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcih2YWxpZGF0ZVJlc3VsdCwgdmFsaWRhdGVSZWYsIGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbGlkYXRlRXJyb3IpLCBhcHBlbmRFcnJvcnNDdXJyeShrZXksIHZhbGlkYXRlRXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB2YWxpZGF0aW9uUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbih7IHJlZjogdmFsaWRhdGVSZWYgfSwgdmFsaWRhdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBlcnJvcjtcclxufTtcblxuY29uc3QgcGFyc2VFcnJvclNjaGVtYSA9IChlcnJvciwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSA9PiBpc0FycmF5KGVycm9yLmlubmVyKVxyXG4gICAgPyBlcnJvci5pbm5lci5yZWR1Y2UoKHByZXZpb3VzLCB7IHBhdGgsIG1lc3NhZ2UsIHR5cGUgfSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldmlvdXMpLCAocGF0aFxyXG4gICAgICAgID8gcHJldmlvdXNbcGF0aF0gJiYgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXHJcbiAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgW3BhdGhdOiBhcHBlbmRFcnJvcnMocGF0aCwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBwcmV2aW91cywgdHlwZSwgbWVzc2FnZSksXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICBbcGF0aF06IHByZXZpb3VzW3BhdGhdIHx8IE9iamVjdC5hc3NpZ24oeyBtZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgfSwgKHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYVxyXG4gICAgICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogeyBbdHlwZV06IG1lc3NhZ2UgfHwgdHJ1ZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHt9KSksXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA6IHt9KSkpLCB7fSlcclxuICAgIDoge1xyXG4gICAgICAgIFtlcnJvci5wYXRoXTogeyBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLCB0eXBlOiBlcnJvci50eXBlIH0sXHJcbiAgICB9O1xyXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVdpdGhTY2hlbWEodmFsaWRhdGlvblNjaGVtYSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBkYXRhLCB2YWxpZGF0aW9uUmVzb2x2ZXIsIGNvbnRleHQpIHtcclxuICAgIGlmICh2YWxpZGF0aW9uUmVzb2x2ZXIpIHtcclxuICAgICAgICByZXR1cm4gdmFsaWRhdGlvblJlc29sdmVyKGRhdGEsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2YWx1ZXM6IGF3YWl0IHZhbGlkYXRpb25TY2hlbWEudmFsaWRhdGUoZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgYWJvcnRFYXJseTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgZXJyb3JzOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2YWx1ZXM6IHt9LFxyXG4gICAgICAgICAgICBlcnJvcnM6IHRyYW5zZm9ybVRvTmVzdE9iamVjdChwYXJzZUVycm9yU2NoZW1hKGUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxudmFyIGlzUHJpbWl0aXZlID0gKHZhbHVlKSA9PiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHwgIWlzT2JqZWN0VHlwZSh2YWx1ZSk7XG5cbmNvbnN0IGdldFBhdGggPSAocGF0aCwgdmFsdWVzKSA9PiB7XHJcbiAgICBjb25zdCBnZXRJbm5lclBhdGggPSAodmFsdWUsIGtleSwgaXNPYmplY3QpID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoV2l0aEluZGV4ID0gaXNPYmplY3QgPyBgJHtwYXRofS4ke2tleX1gIDogYCR7cGF0aH1bJHtrZXl9XWA7XHJcbiAgICAgICAgcmV0dXJuIGlzUHJpbWl0aXZlKHZhbHVlKSA/IHBhdGhXaXRoSW5kZXggOiBnZXRQYXRoKHBhdGhXaXRoSW5kZXgsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZXMpXHJcbiAgICAgICAgPyB2YWx1ZXMubWFwKCh2YWx1ZSwga2V5KSA9PiBnZXRJbm5lclBhdGgodmFsdWUsIGtleSkpXHJcbiAgICAgICAgOiBPYmplY3QuZW50cmllcyh2YWx1ZXMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBnZXRJbm5lclBhdGgodmFsdWUsIGtleSwgdHJ1ZSkpO1xyXG59O1xyXG52YXIgZ2V0UGF0aCQxID0gKHBhcmVudFBhdGgsIHZhbHVlKSA9PiBnZXRQYXRoKHBhcmVudFBhdGgsIHZhbHVlKS5mbGF0KEluZmluaXR5KTtcblxudmFyIGFzc2lnbldhdGNoRmllbGRzID0gKGZpZWxkVmFsdWVzLCBmaWVsZE5hbWUsIHdhdGNoRmllbGRzLCBpbnB1dFZhbHVlLCBpc1NpbmdsZUZpZWxkKSA9PiB7XHJcbiAgICBsZXQgdmFsdWU7XHJcbiAgICB3YXRjaEZpZWxkcy5hZGQoZmllbGROYW1lKTtcclxuICAgIGlmIChpc0VtcHR5T2JqZWN0KGZpZWxkVmFsdWVzKSkge1xyXG4gICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKGZpZWxkVmFsdWVzW2ZpZWxkTmFtZV0pKSB7XHJcbiAgICAgICAgdmFsdWUgPSBmaWVsZFZhbHVlc1tmaWVsZE5hbWVdO1xyXG4gICAgICAgIHdhdGNoRmllbGRzLmFkZChmaWVsZE5hbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSBnZXQodHJhbnNmb3JtVG9OZXN0T2JqZWN0KGZpZWxkVmFsdWVzKSwgZmllbGROYW1lKTtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBnZXRQYXRoJDEoZmllbGROYW1lLCB2YWx1ZSkuZm9yRWFjaCgobmFtZSkgPT4gd2F0Y2hGaWVsZHMuYWRkKG5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmFsdWUpXHJcbiAgICAgICAgPyBpc1NpbmdsZUZpZWxkXHJcbiAgICAgICAgICAgID8gaW5wdXRWYWx1ZVxyXG4gICAgICAgICAgICA6IGdldChpbnB1dFZhbHVlLCBmaWVsZE5hbWUpXHJcbiAgICAgICAgOiB2YWx1ZTtcclxufTtcblxudmFyIHNraXBWYWxpZGF0aW9uID0gKHsgaXNPbkNoYW5nZSwgaGFzRXJyb3IsIGlzQmx1ckV2ZW50LCBpc09uU3VibWl0LCBpc1JlVmFsaWRhdGVPblN1Ym1pdCwgaXNPbkJsdXIsIGlzUmVWYWxpZGF0ZU9uQmx1ciwgaXNTdWJtaXR0ZWQsIH0pID0+IChpc09uQ2hhbmdlICYmIGlzQmx1ckV2ZW50KSB8fFxyXG4gICAgKGlzT25TdWJtaXQgJiYgaXNSZVZhbGlkYXRlT25TdWJtaXQpIHx8XHJcbiAgICAoaXNPblN1Ym1pdCAmJiAhaXNTdWJtaXR0ZWQpIHx8XHJcbiAgICAoaXNPbkJsdXIgJiYgIWlzQmx1ckV2ZW50ICYmICFoYXNFcnJvcikgfHxcclxuICAgIChpc1JlVmFsaWRhdGVPbkJsdXIgJiYgIWlzQmx1ckV2ZW50ICYmIGhhc0Vycm9yKSB8fFxyXG4gICAgKGlzUmVWYWxpZGF0ZU9uU3VibWl0ICYmIGlzU3VibWl0dGVkKTtcblxudmFyIGdldEZpZWxkQXJyYXlQYXJlbnROYW1lID0gKG5hbWUpID0+IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUuaW5kZXhPZignWycpKTtcblxudmFyIGdldEZpZWxkVmFsdWVCeU5hbWUgPSAoZmllbGRzLCBuYW1lKSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gdHJhbnNmb3JtVG9OZXN0T2JqZWN0KGdldEZpZWxkc1ZhbHVlcyhmaWVsZHMpKTtcclxuICAgIHJldHVybiBuYW1lID8gZ2V0KHJlc3VsdHMsIG5hbWUsIHJlc3VsdHMpIDogcmVzdWx0cztcclxufTtcblxuZnVuY3Rpb24gZ2V0SXNGaWVsZHNEaWZmZXJlbnQocmVmZXJlbmNlQXJyYXksIGRpZmZlcmVuY2VBcnJheSkge1xyXG4gICAgbGV0IGlzTWF0Y2ggPSBmYWxzZTtcclxuICAgIGlmICghaXNBcnJheShyZWZlcmVuY2VBcnJheSkgfHxcclxuICAgICAgICAhaXNBcnJheShkaWZmZXJlbmNlQXJyYXkpIHx8XHJcbiAgICAgICAgcmVmZXJlbmNlQXJyYXkubGVuZ3RoICE9PSBkaWZmZXJlbmNlQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZUFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGlzTWF0Y2gpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGFBID0gcmVmZXJlbmNlQXJyYXlbaV07XHJcbiAgICAgICAgY29uc3QgZGF0YUIgPSBkaWZmZXJlbmNlQXJyYXlbaV07XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGFCKSB8fFxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhQSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhkYXRhQikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlzTWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YUEpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFBW2tleV0gIT09IGRhdGFCW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIGlzTWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNNYXRjaDtcclxufVxuXG5jb25zdCBpc01hdGNoRmllbGRBcnJheU5hbWUgPSAobmFtZSwgc2VhcmNoTmFtZSkgPT4gUmVnRXhwKGBeJHtzZWFyY2hOYW1lfVtcXFxcZCtdYC5yZXBsYWNlKC9cXFsvZywgJ1xcXFxbJykucmVwbGFjZSgvXFxdL2csICdcXFxcXScpKS50ZXN0KG5hbWUpO1xyXG52YXIgaXNOYW1lSW5GaWVsZEFycmF5ID0gKG5hbWVzLCBuYW1lKSA9PiBbLi4ubmFtZXNdLnNvbWUoKGN1cnJlbnQpID0+IGlzTWF0Y2hGaWVsZEFycmF5TmFtZShuYW1lLCBjdXJyZW50KSk7XG5cbnZhciBpc1NlbGVjdElucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gYCR7U0VMRUNUfS1vbmVgO1xuXG5mdW5jdGlvbiBvbkRvbVJlbW92ZShlbGVtZW50LCBvbkRldGFjaENhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcclxuICAgICAgICBpZiAoaXNEZXRhY2hlZChlbGVtZW50KSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIG9uRGV0YWNoQ2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIG9ic2VydmVyLm9ic2VydmUod2luZG93LmRvY3VtZW50LCB7XHJcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYnNlcnZlcjtcclxufVxuXG52YXIgbW9kZUNoZWNrZXIgPSAobW9kZSkgPT4gKHtcclxuICAgIGlzT25TdWJtaXQ6ICFtb2RlIHx8IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcclxuICAgIGlzT25CbHVyOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25CbHVyLFxyXG4gICAgaXNPbkNoYW5nZTogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLFxyXG59KTtcblxudmFyIGlzUmFkaW9PckNoZWNrYm94RnVuY3Rpb24gPSAocmVmKSA9PiBpc1JhZGlvSW5wdXQocmVmKSB8fCBpc0NoZWNrQm94SW5wdXQocmVmKTtcblxuZnVuY3Rpb24gdXNlRm9ybSh7IG1vZGUgPSBWQUxJREFUSU9OX01PREUub25TdWJtaXQsIHJlVmFsaWRhdGVNb2RlID0gVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLCB2YWxpZGF0aW9uU2NoZW1hLCB2YWxpZGF0aW9uUmVzb2x2ZXIsIHZhbGlkYXRpb25Db250ZXh0LCBkZWZhdWx0VmFsdWVzID0ge30sIHN1Ym1pdEZvY3VzRXJyb3IgPSB0cnVlLCB2YWxpZGF0ZUNyaXRlcmlhTW9kZSwgfSA9IHt9KSB7XHJcbiAgICBjb25zdCBmaWVsZHNSZWYgPSB1c2VSZWYoe30pO1xyXG4gICAgY29uc3QgZXJyb3JzUmVmID0gdXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IHRvdWNoZWRGaWVsZHNSZWYgPSB1c2VSZWYoe30pO1xyXG4gICAgY29uc3QgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMgPSB1c2VSZWYoe30pO1xyXG4gICAgY29uc3Qgd2F0Y2hGaWVsZHNSZWYgPSB1c2VSZWYobmV3IFNldCgpKTtcclxuICAgIGNvbnN0IGRpcnR5RmllbGRzUmVmID0gdXNlUmVmKG5ldyBTZXQoKSk7XHJcbiAgICBjb25zdCBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZiA9IHVzZVJlZihuZXcgU2V0KCkpO1xyXG4gICAgY29uc3QgdmFsaWRGaWVsZHNSZWYgPSB1c2VSZWYobmV3IFNldCgpKTtcclxuICAgIGNvbnN0IGlzVmFsaWRSZWYgPSB1c2VSZWYodHJ1ZSk7XHJcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVzUmVmID0gdXNlUmVmKGRlZmF1bHRWYWx1ZXMpO1xyXG4gICAgY29uc3QgZGVmYXVsdFZhbHVlc0F0UmVuZGVyUmVmID0gdXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IGlzVW5Nb3VudCA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICBjb25zdCBpc1dhdGNoQWxsUmVmID0gdXNlUmVmKGZhbHNlKTtcclxuICAgIGNvbnN0IGlzU3VibWl0dGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcclxuICAgIGNvbnN0IGlzRGlydHlSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3Qgc3VibWl0Q291bnRSZWYgPSB1c2VSZWYoMCk7XHJcbiAgICBjb25zdCBpc1N1Ym1pdHRpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlUmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCByZXNldEZpZWxkQXJyYXlGdW5jdGlvblJlZiA9IHVzZVJlZih7fSk7XHJcbiAgICBjb25zdCB2YWxpZGF0aW9uQ29udGV4dFJlZiA9IHVzZVJlZih2YWxpZGF0aW9uQ29udGV4dCk7XHJcbiAgICBjb25zdCBmaWVsZEFycmF5TmFtZXNSZWYgPSB1c2VSZWYobmV3IFNldCgpKTtcclxuICAgIGNvbnN0IFssIHJlbmRlcl0gPSB1c2VTdGF0ZSgpO1xyXG4gICAgY29uc3QgeyBpc09uQmx1ciwgaXNPblN1Ym1pdCwgaXNPbkNoYW5nZSB9ID0gdXNlUmVmKG1vZGVDaGVja2VyKG1vZGUpKS5jdXJyZW50O1xyXG4gICAgY29uc3QgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhID0gdmFsaWRhdGVDcml0ZXJpYU1vZGUgPT09ICdhbGwnO1xyXG4gICAgY29uc3QgaXNXaW5kb3dVbmRlZmluZWQgPSB0eXBlb2Ygd2luZG93ID09PSBVTkRFRklORUQ7XHJcbiAgICBjb25zdCBzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIgPSAhISh2YWxpZGF0aW9uU2NoZW1hIHx8IHZhbGlkYXRpb25SZXNvbHZlcik7XHJcbiAgICBjb25zdCBpc1dlYiA9IHR5cGVvZiBkb2N1bWVudCAhPT0gVU5ERUZJTkVEICYmXHJcbiAgICAgICAgIWlzV2luZG93VW5kZWZpbmVkICYmXHJcbiAgICAgICAgIWlzVW5kZWZpbmVkKHdpbmRvdy5IVE1MRWxlbWVudCk7XHJcbiAgICBjb25zdCBpc1Byb3h5RW5hYmxlZCA9IGlzV2ViID8gJ1Byb3h5JyBpbiB3aW5kb3cgOiB0eXBlb2YgUHJveHkgIT09IFVOREVGSU5FRDtcclxuICAgIGNvbnN0IHJlYWRGb3JtU3RhdGVSZWYgPSB1c2VSZWYoe1xyXG4gICAgICAgIGRpcnR5OiAhaXNQcm94eUVuYWJsZWQsXHJcbiAgICAgICAgZGlydHlGaWVsZHM6ICFpc1Byb3h5RW5hYmxlZCxcclxuICAgICAgICBpc1N1Ym1pdHRlZDogaXNPblN1Ym1pdCxcclxuICAgICAgICBzdWJtaXRDb3VudDogIWlzUHJveHlFbmFibGVkLFxyXG4gICAgICAgIHRvdWNoZWQ6ICFpc1Byb3h5RW5hYmxlZCxcclxuICAgICAgICBpc1N1Ym1pdHRpbmc6ICFpc1Byb3h5RW5hYmxlZCxcclxuICAgICAgICBpc1ZhbGlkOiAhaXNQcm94eUVuYWJsZWQsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHsgaXNPbkJsdXI6IGlzUmVWYWxpZGF0ZU9uQmx1ciwgaXNPblN1Ym1pdDogaXNSZVZhbGlkYXRlT25TdWJtaXQsIH0gPSB1c2VSZWYobW9kZUNoZWNrZXIocmVWYWxpZGF0ZU1vZGUpKS5jdXJyZW50O1xyXG4gICAgdmFsaWRhdGlvbkNvbnRleHRSZWYuY3VycmVudCA9IHZhbGlkYXRpb25Db250ZXh0O1xyXG4gICAgY29uc3QgcmVSZW5kZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFpc1VuTW91bnQuY3VycmVudCkge1xyXG4gICAgICAgICAgICByZW5kZXIoe30pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHNob3VsZFJlbmRlckJhc2VPbkVycm9yID0gdXNlQ2FsbGJhY2soKG5hbWUsIGVycm9yLCBzaG91bGRSZW5kZXIgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGxldCBzaG91bGRSZVJlbmRlciA9IHNob3VsZFJlbmRlciB8fFxyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXJCYXNlZE9uRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIHZhbGlkRmllbGRzOiB2YWxpZEZpZWxkc1JlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgZmllbGRzV2l0aFZhbGlkYXRpb246IGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KGVycm9yKSkge1xyXG4gICAgICAgICAgICBpZiAoZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudC5oYXMobmFtZSkgfHxcclxuICAgICAgICAgICAgICAgIHNob3VsZFZhbGlkYXRlU2NoZW1hT3JSZXNvbHZlcikge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRGaWVsZHNSZWYuY3VycmVudC5hZGQobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRSZVJlbmRlciA9IHNob3VsZFJlUmVuZGVyIHx8IGdldChlcnJvcnNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXJyb3JzUmVmLmN1cnJlbnQgPSB1bnNldChlcnJvcnNSZWYuY3VycmVudCwgW25hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3IgPSBnZXQoZXJyb3JzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgICAgICB2YWxpZEZpZWxkc1JlZi5jdXJyZW50LmRlbGV0ZShuYW1lKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVSZW5kZXIgPVxyXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVSZW5kZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAocHJldmlvdXNFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICFpc1NhbWVFcnJvcihwcmV2aW91c0Vycm9yLCBlcnJvcltuYW1lXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlKTtcclxuICAgICAgICAgICAgc2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lLCBlcnJvcltuYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRSZVJlbmRlciAmJiAhaXNOdWxsT3JVbmRlZmluZWQoc2hvdWxkUmVuZGVyKSkge1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbcmVSZW5kZXIsIHNob3VsZFZhbGlkYXRlU2NoZW1hT3JSZXNvbHZlcl0pO1xyXG4gICAgY29uc3Qgc2V0RmllbGRWYWx1ZSA9IHVzZUNhbGxiYWNrKChmaWVsZCwgcmF3VmFsdWUpID0+IHtcclxuICAgICAgICBjb25zdCB7IHJlZiwgb3B0aW9ucyB9ID0gZmllbGQ7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpc1dlYiAmJiBpc0hUTUxFbGVtZW50KHJlZikgJiYgaXNOdWxsT3JVbmRlZmluZWQocmF3VmFsdWUpXHJcbiAgICAgICAgICAgID8gJydcclxuICAgICAgICAgICAgOiByYXdWYWx1ZTtcclxuICAgICAgICBpZiAoaXNSYWRpb0lucHV0KHJlZikgJiYgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmZvckVhY2goKHsgcmVmOiByYWRpb1JlZiB9KSA9PiAocmFkaW9SZWYuY2hlY2tlZCA9IHJhZGlvUmVmLnZhbHVlID09PSB2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0ZpbGVJbnB1dChyZWYpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVmLmZpbGVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNNdWx0aXBsZVNlbGVjdChyZWYpKSB7XHJcbiAgICAgICAgICAgIFsuLi5yZWYub3B0aW9uc10uZm9yRWFjaCgoc2VsZWN0UmVmKSA9PiAoc2VsZWN0UmVmLnNlbGVjdGVkID0gdmFsdWUuaW5jbHVkZXMoc2VsZWN0UmVmLnZhbHVlKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0NoZWNrQm94SW5wdXQocmVmKSAmJiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmZvckVhY2goKHsgcmVmOiBjaGVja2JveFJlZiB9KSA9PiAoY2hlY2tib3hSZWYuY2hlY2tlZCA9IHZhbHVlLmluY2x1ZGVzKGNoZWNrYm94UmVmLnZhbHVlKSkpXHJcbiAgICAgICAgICAgICAgICA6IChvcHRpb25zWzBdLnJlZi5jaGVja2VkID0gISF2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbaXNXZWJdKTtcclxuICAgIGNvbnN0IHNldERpcnR5ID0gdXNlQ2FsbGJhY2soKG5hbWUpID0+IHtcclxuICAgICAgICBpZiAoIWZpZWxkc1JlZi5jdXJyZW50W25hbWVdIHx8XHJcbiAgICAgICAgICAgICghcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5ICYmICFyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGlzRmllbGREaXJ0eSA9IGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZi5jdXJyZW50W25hbWVdICE9PVxyXG4gICAgICAgICAgICBnZXRGaWVsZFZhbHVlKGZpZWxkc1JlZi5jdXJyZW50LCBmaWVsZHNSZWYuY3VycmVudFtuYW1lXS5yZWYpO1xyXG4gICAgICAgIGNvbnN0IGlzRmllbGRBcnJheSA9IGlzTmFtZUluRmllbGRBcnJheShmaWVsZEFycmF5TmFtZXNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNEaXJ0eUZpZWxkc0xlbmd0aCA9IGRpcnR5RmllbGRzUmVmLmN1cnJlbnQuc2l6ZTtcclxuICAgICAgICBpZiAoaXNGaWVsZEFycmF5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkQXJyYXlOYW1lID0gZ2V0RmllbGRBcnJheVBhcmVudE5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlzRmllbGREaXJ0eSA9IGdldElzRmllbGRzRGlmZmVyZW50KGdldEZpZWxkVmFsdWVCeU5hbWUoZmllbGRzUmVmLmN1cnJlbnQsIGZpZWxkQXJyYXlOYW1lKSwgZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgZmllbGRBcnJheU5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNEaXJ0eUNoYW5nZWQgPSAoaXNGaWVsZEFycmF5ID8gaXNEaXJ0eVJlZi5jdXJyZW50IDogZGlydHlGaWVsZHNSZWYuY3VycmVudC5oYXMobmFtZSkpICE9PVxyXG4gICAgICAgICAgICBpc0ZpZWxkRGlydHk7XHJcbiAgICAgICAgaWYgKGlzRmllbGREaXJ0eSkge1xyXG4gICAgICAgICAgICBkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LmFkZChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRpcnR5RmllbGRzUmVmLmN1cnJlbnQuZGVsZXRlKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc0RpcnR5UmVmLmN1cnJlbnQgPSBpc0ZpZWxkQXJyYXlcclxuICAgICAgICAgICAgPyBpc0ZpZWxkRGlydHlcclxuICAgICAgICAgICAgOiAhIWRpcnR5RmllbGRzUmVmLmN1cnJlbnQuc2l6ZTtcclxuICAgICAgICByZXR1cm4gcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5XHJcbiAgICAgICAgICAgID8gaXNEaXJ0eUNoYW5nZWRcclxuICAgICAgICAgICAgOiBwcmV2aW91c0RpcnR5RmllbGRzTGVuZ3RoICE9PSBkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LnNpemU7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCBzZXRJbnRlcm5hbFZhbHVlcyA9IHVzZUNhbGxiYWNrKChuYW1lLCB2YWx1ZSwgcGFyZW50RmllbGROYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNWYWx1ZUFycmF5ID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gYCR7cGFyZW50RmllbGROYW1lIHx8IG5hbWV9JHtpc1ZhbHVlQXJyYXkgPyBgWyR7a2V5fV1gIDogYC4ke2tleX1gfWA7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzUmVmLmN1cnJlbnRbZmllbGROYW1lXTtcclxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRJbnRlcm5hbFZhbHVlcyhuYW1lLCB2YWx1ZVtrZXldLCBmaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0RmllbGRWYWx1ZShmaWVsZCwgdmFsdWVba2V5XSk7XHJcbiAgICAgICAgICAgICAgICBzZXREaXJ0eShmaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3NldEZpZWxkVmFsdWUsIHNldERpcnR5XSk7XHJcbiAgICBjb25zdCBzZXRJbnRlcm5hbFZhbHVlID0gdXNlQ2FsbGJhY2soKG5hbWUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNSZWYuY3VycmVudFtuYW1lXTtcclxuICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgc2V0RmllbGRWYWx1ZShmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBzZXREaXJ0eShuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihvdXRwdXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgc2V0SW50ZXJuYWxWYWx1ZXMobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtzZXREaXJ0eSwgc2V0RmllbGRWYWx1ZSwgc2V0SW50ZXJuYWxWYWx1ZXNdKTtcclxuICAgIGNvbnN0IGV4ZWN1dGVWYWxpZGF0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5hbWUsIHNraXBSZVJlbmRlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgdmFsaWRhdGVGaWVsZChmaWVsZHNSZWYsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZmllbGQpO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXJCYXNlT25FcnJvcihuYW1lLCBlcnJvciwgc2tpcFJlUmVuZGVyID8gbnVsbCA6IGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHlPYmplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LCBbc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYV0pO1xyXG4gICAgY29uc3QgZXhlY3V0ZVNjaGVtYU9yUmVzb2x2ZXJWYWxpZGF0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKHBheWxvYWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gYXdhaXQgdmFsaWRhdGVXaXRoU2NoZW1hKHZhbGlkYXRpb25TY2hlbWEsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZ2V0RmllbGRWYWx1ZUJ5TmFtZShmaWVsZHNSZWYuY3VycmVudCksIHZhbGlkYXRpb25SZXNvbHZlciwgdmFsaWRhdGlvbkNvbnRleHRSZWYuY3VycmVudCk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNGb3JtSXNWYWxpZCA9IGlzVmFsaWRSZWYuY3VycmVudDtcclxuICAgICAgICBpc1ZhbGlkUmVmLmN1cnJlbnQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocGF5bG9hZCkpIHtcclxuICAgICAgICAgICAgcGF5bG9hZC5mb3JFYWNoKChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1bnNldChlcnJvcnNSZWYuY3VycmVudCwgW25hbWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIHBheWxvYWQpO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXJCYXNlT25FcnJvcihwYXlsb2FkLCAoZXJyb3IgPyB7IFtwYXlsb2FkXTogZXJyb3IgfSA6IHt9KSwgcHJldmlvdXNGb3JtSXNWYWxpZCAhPT0gaXNWYWxpZFJlZi5jdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzRW1wdHlPYmplY3QoZXJyb3JzUmVmLmN1cnJlbnQpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIHJlUmVuZGVyLFxyXG4gICAgICAgIHNob3VsZFJlbmRlckJhc2VPbkVycm9yLFxyXG4gICAgICAgIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSxcclxuICAgICAgICB2YWxpZGF0aW9uUmVzb2x2ZXIsXHJcbiAgICAgICAgdmFsaWRhdGlvblNjaGVtYSxcclxuICAgIF0pO1xyXG4gICAgY29uc3QgdHJpZ2dlclZhbGlkYXRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAocGF5bG9hZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHBheWxvYWQgfHwgT2JqZWN0LmtleXMoZmllbGRzUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGlmIChzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVTY2hlbWFPclJlc29sdmVyVmFsaWRhdGlvbihmaWVsZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheShmaWVsZHMpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKGZpZWxkcy5tYXAoYXN5bmMgKGRhdGEpID0+IGF3YWl0IGV4ZWN1dGVWYWxpZGF0aW9uKGRhdGEsIHRydWUpKSk7XHJcbiAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZXZlcnkoQm9vbGVhbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBleGVjdXRlVmFsaWRhdGlvbihmaWVsZHMpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIGV4ZWN1dGVTY2hlbWFPclJlc29sdmVyVmFsaWRhdGlvbixcclxuICAgICAgICBleGVjdXRlVmFsaWRhdGlvbixcclxuICAgICAgICByZVJlbmRlcixcclxuICAgICAgICBzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIsXHJcbiAgICBdKTtcclxuICAgIGNvbnN0IGlzRmllbGRXYXRjaGVkID0gKG5hbWUpID0+IGlzV2F0Y2hBbGxSZWYuY3VycmVudCB8fFxyXG4gICAgICAgIHdhdGNoRmllbGRzUmVmLmN1cnJlbnQuaGFzKG5hbWUpIHx8XHJcbiAgICAgICAgd2F0Y2hGaWVsZHNSZWYuY3VycmVudC5oYXMoKG5hbWUubWF0Y2goL1xcdysvKSB8fCBbXSlbMF0pO1xyXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUobmFtZXMsIHZhbHVlT3JTaG91bGRWYWxpZGF0ZSwgc2hvdWxkVmFsaWRhdGUpIHtcclxuICAgICAgICBsZXQgc2hvdWxkUmVuZGVyID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgaXNBcnJheVZhbHVlID0gaXNBcnJheShuYW1lcyk7XHJcbiAgICAgICAgKGlzQXJyYXlWYWx1ZVxyXG4gICAgICAgICAgICA/IG5hbWVzXHJcbiAgICAgICAgICAgIDogW25hbWVzXSkuZm9yRWFjaCgobmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpc1N0cmluZ0ZpZWxkTmFtZSA9IGlzU3RyaW5nKG5hbWUpO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXIgPVxyXG4gICAgICAgICAgICAgICAgc2V0SW50ZXJuYWxWYWx1ZShpc1N0cmluZ0ZpZWxkTmFtZSA/IG5hbWUgOiBPYmplY3Qua2V5cyhuYW1lKVswXSwgaXNTdHJpbmdGaWVsZE5hbWVcclxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlT3JTaG91bGRWYWxpZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LnZhbHVlcyhuYW1lKVswXSkgfHwgaXNBcnJheVZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc0ZpZWxkV2F0Y2hlZChuYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc2hvdWxkUmVuZGVyIHx8IGlzQXJyYXlWYWx1ZSkge1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkVmFsaWRhdGUgfHwgKGlzQXJyYXlWYWx1ZSAmJiB2YWx1ZU9yU2hvdWxkVmFsaWRhdGUpKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJWYWxpZGF0aW9uKGlzQXJyYXlWYWx1ZSA/IHVuZGVmaW5lZCA6IG5hbWVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDaGFuZ2VSZWYuY3VycmVudCA9IGhhbmRsZUNoYW5nZVJlZi5jdXJyZW50XHJcbiAgICAgICAgPyBoYW5kbGVDaGFuZ2VSZWYuY3VycmVudFxyXG4gICAgICAgIDogYXN5bmMgKHsgdHlwZSwgdGFyZ2V0IH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRhcmdldCA/IHRhcmdldC5uYW1lIDogJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IGZpZWxkc1JlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBlcnJvcnNSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbbmFtZV07XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xyXG4gICAgICAgICAgICBsZXQgZXJyb3I7XHJcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpc0JsdXJFdmVudCA9IHR5cGUgPT09IEVWRU5UUy5CTFVSO1xyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRTa2lwVmFsaWRhdGlvbiA9IHNraXBWYWxpZGF0aW9uKHtcclxuICAgICAgICAgICAgICAgIGhhc0Vycm9yOiAhIWN1cnJlbnRFcnJvcixcclxuICAgICAgICAgICAgICAgIGlzT25DaGFuZ2UsXHJcbiAgICAgICAgICAgICAgICBpc0JsdXJFdmVudCxcclxuICAgICAgICAgICAgICAgIGlzT25TdWJtaXQsXHJcbiAgICAgICAgICAgICAgICBpc1JlVmFsaWRhdGVPblN1Ym1pdCxcclxuICAgICAgICAgICAgICAgIGlzT25CbHVyLFxyXG4gICAgICAgICAgICAgICAgaXNSZVZhbGlkYXRlT25CbHVyLFxyXG4gICAgICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IGlzU3VibWl0dGVkUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRVcGRhdGVEaXJ0eSA9IHNldERpcnR5KG5hbWUpO1xyXG4gICAgICAgICAgICBsZXQgc2hvdWxkUmVuZGVyID0gaXNGaWVsZFdhdGNoZWQobmFtZSkgfHwgc2hvdWxkVXBkYXRlRGlydHk7XHJcbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCAmJlxyXG4gICAgICAgICAgICAgICAgIWdldCh0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpICYmXHJcbiAgICAgICAgICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZFJlbmRlciAmJiByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBhd2FpdCB2YWxpZGF0ZVdpdGhTY2hlbWEodmFsaWRhdGlvblNjaGVtYSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBnZXRGaWVsZFZhbHVlQnlOYW1lKGZpZWxkcyksIHZhbGlkYXRpb25SZXNvbHZlciwgdmFsaWRhdGlvbkNvbnRleHRSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0Zvcm1Jc1ZhbGlkID0gaXNWYWxpZFJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgaXNWYWxpZFJlZi5jdXJyZW50ID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSAoZ2V0KGVycm9ycywgbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICA/IHsgW25hbWVdOiBnZXQoZXJyb3JzLCBuYW1lKSB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7fSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNGb3JtSXNWYWxpZCAhPT0gaXNWYWxpZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gYXdhaXQgdmFsaWRhdGVGaWVsZChmaWVsZHNSZWYsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZmllbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IobmFtZSwgZXJyb3IpICYmIHNob3VsZFJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICBjb25zdCB2YWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIgPSB1c2VDYWxsYmFjaygodmFsdWVzID0ge30pID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGlzRW1wdHlPYmplY3QoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50KVxyXG4gICAgICAgICAgICA/IGdldEZpZWxkc1ZhbHVlcyhmaWVsZHNSZWYuY3VycmVudClcclxuICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgdmFsaWRhdGVXaXRoU2NoZW1hKHZhbGlkYXRpb25TY2hlbWEsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgdHJhbnNmb3JtVG9OZXN0T2JqZWN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGRWYWx1ZXMpLCB2YWx1ZXMpKSwgdmFsaWRhdGlvblJlc29sdmVyLCB2YWxpZGF0aW9uQ29udGV4dFJlZi5jdXJyZW50KS50aGVuKCh7IGVycm9ycyB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRm9ybUlzVmFsaWQgPSBpc1ZhbGlkUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGlzVmFsaWRSZWYuY3VycmVudCA9IGlzRW1wdHlPYmplY3QoZXJyb3JzKTtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzRm9ybUlzVmFsaWQgIT09IGlzVmFsaWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICBbcmVSZW5kZXIsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgdmFsaWRhdGlvblJlc29sdmVyXSk7XHJcbiAgICBjb25zdCByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIgPSB1c2VDYWxsYmFjaygoZmllbGQsIGZvcmNlRGVsZXRlKSA9PiB7XHJcbiAgICAgICAgaWYgKGhhbmRsZUNoYW5nZVJlZi5jdXJyZW50ICYmIGZpZWxkKSB7XHJcbiAgICAgICAgICAgIGZpbmRSZW1vdmVkRmllbGRBbmRSZW1vdmVMaXN0ZW5lcihmaWVsZHNSZWYuY3VycmVudCwgaGFuZGxlQ2hhbmdlUmVmLmN1cnJlbnQsIGZpZWxkLCBmb3JjZURlbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyQW5kUmVmID0gdXNlQ2FsbGJhY2soKGZpZWxkLCBmb3JjZURlbGV0ZSkgPT4ge1xyXG4gICAgICAgIGlmICghZmllbGQgfHxcclxuICAgICAgICAgICAgKGZpZWxkICYmXHJcbiAgICAgICAgICAgICAgICBpc05hbWVJbkZpZWxkQXJyYXkoZmllbGRBcnJheU5hbWVzUmVmLmN1cnJlbnQsIGZpZWxkLnJlZi5uYW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgIWZvcmNlRGVsZXRlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lcihmaWVsZCwgZm9yY2VEZWxldGUpO1xyXG4gICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gZmllbGQucmVmO1xyXG4gICAgICAgIGVycm9yc1JlZi5jdXJyZW50ID0gdW5zZXQoZXJyb3JzUmVmLmN1cnJlbnQsIFtuYW1lXSk7XHJcbiAgICAgICAgdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50ID0gdW5zZXQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50LCBbbmFtZV0pO1xyXG4gICAgICAgIGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZi5jdXJyZW50ID0gdW5zZXQoZGVmYXVsdFZhbHVlc0F0UmVuZGVyUmVmLmN1cnJlbnQsIFtuYW1lXSk7XHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICBkaXJ0eUZpZWxkc1JlZixcclxuICAgICAgICAgICAgZmllbGRzV2l0aFZhbGlkYXRpb25SZWYsXHJcbiAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLFxyXG4gICAgICAgICAgICB3YXRjaEZpZWxkc1JlZixcclxuICAgICAgICBdLmZvckVhY2goKGRhdGEpID0+IGRhdGEuY3VycmVudC5kZWxldGUobmFtZSkpO1xyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZCB8fFxyXG4gICAgICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCkge1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVmFsaWRhdGVTY2hlbWFPclJlc29sdmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtcclxuICAgICAgICByZVJlbmRlcixcclxuICAgICAgICBzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIsXHJcbiAgICAgICAgdmFsaWRhdGVTY2hlbWFPclJlc29sdmVyLFxyXG4gICAgICAgIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lcixcclxuICAgIF0pO1xyXG4gICAgZnVuY3Rpb24gY2xlYXJFcnJvcihuYW1lKSB7XHJcbiAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgdW5zZXQoZXJyb3JzUmVmLmN1cnJlbnQsIGlzQXJyYXkobmFtZSkgPyBuYW1lIDogW25hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVycm9yc1JlZi5jdXJyZW50ID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXRJbnRlcm5hbEVycm9yID0gKHsgbmFtZSwgdHlwZSwgdHlwZXMsIG1lc3NhZ2UsIHNob3VsZFJlbmRlciwgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICAgICAgaWYgKCFpc1NhbWVFcnJvcihnZXQoZXJyb3JzUmVmLmN1cnJlbnQsIG5hbWUpLCB7XHJcbiAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgIHR5cGVzLFxyXG4gICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgIHNldChlcnJvcnNSZWYuY3VycmVudCwgbmFtZSwge1xyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIHR5cGVzLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIHJlZjogZmllbGQgPyBmaWVsZC5yZWYgOiB7fSxcclxuICAgICAgICAgICAgICAgIGlzTWFudWFsOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBzZXRFcnJvcihuYW1lLCB0eXBlID0gJycsIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoaXNTdHJpbmcobmFtZSkpIHtcclxuICAgICAgICAgICAgc2V0SW50ZXJuYWxFcnJvcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBuYW1lIH0sIChpc09iamVjdCh0eXBlKVxyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZXM6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJycsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB9KSksIHsgc2hvdWxkUmVuZGVyOiB0cnVlIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheShuYW1lKSkge1xyXG4gICAgICAgICAgICBuYW1lLmZvckVhY2goKGVycm9yKSA9PiBzZXRJbnRlcm5hbEVycm9yKE9iamVjdC5hc3NpZ24oe30sIGVycm9yKSkpO1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHdhdGNoKGZpZWxkTmFtZXMsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHdhdGNoRmllbGRzID0gd2F0Y2hGaWVsZHNSZWYuY3VycmVudDtcclxuICAgICAgICBjb25zdCBpc0RlZmF1bHRWYWx1ZVVuZGVmaW5lZCA9IGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgY29tYmluZWREZWZhdWx0VmFsdWVzID0gaXNEZWZhdWx0VmFsdWVVbmRlZmluZWRcclxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnRcclxuICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZHNWYWx1ZXMoZmllbGRzUmVmLmN1cnJlbnQsIGZpZWxkTmFtZXMpO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhmaWVsZE5hbWVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXNzaWduV2F0Y2hGaWVsZHMoZmllbGRWYWx1ZXMsIGZpZWxkTmFtZXMsIHdhdGNoRmllbGRzLCBpc0RlZmF1bHRWYWx1ZVVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBnZXQoY29tYmluZWREZWZhdWx0VmFsdWVzLCBmaWVsZE5hbWVzKVxyXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheShmaWVsZE5hbWVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGROYW1lcy5yZWR1Y2UoKHByZXZpb3VzLCBuYW1lKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2aW91cyksIHsgW25hbWVdOiBhc3NpZ25XYXRjaEZpZWxkcyhmaWVsZFZhbHVlcywgbmFtZSwgd2F0Y2hGaWVsZHMsIGNvbWJpbmVkRGVmYXVsdFZhbHVlcykgfSkpLCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzV2F0Y2hBbGxSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKCFpc0VtcHR5T2JqZWN0KGZpZWxkVmFsdWVzKSAmJiBmaWVsZFZhbHVlcykgfHwgY29tYmluZWREZWZhdWx0VmFsdWVzO1xyXG4gICAgICAgIHJldHVybiBmaWVsZE5hbWVzICYmIGZpZWxkTmFtZXMubmVzdFxyXG4gICAgICAgICAgICA/IHRyYW5zZm9ybVRvTmVzdE9iamVjdChyZXN1bHQpXHJcbiAgICAgICAgICAgIDogcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdW5yZWdpc3RlcihuYW1lKSB7XHJcbiAgICAgICAgaWYgKGZpZWxkc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIChpc0FycmF5KG5hbWUpID8gbmFtZSA6IFtuYW1lXSkuZm9yRWFjaCgoZmllbGROYW1lKSA9PiByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXJBbmRSZWYoZmllbGRzUmVmLmN1cnJlbnRbZmllbGROYW1lXSwgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRmllbGRzUmVmKHJlZiwgdmFsaWRhdGVPcHRpb25zID0ge30pIHtcclxuICAgICAgICBpZiAoIXJlZi5uYW1lKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ01pc3NpbmcgbmFtZSBAJywgcmVmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBuYW1lLCB0eXBlLCB2YWx1ZSB9ID0gcmVmO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkUmVmQW5kVmFsaWRhdGlvbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgcmVmIH0sIHZhbGlkYXRlT3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgZmllbGRzID0gZmllbGRzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgaXNSYWRpb09yQ2hlY2tib3ggPSBpc1JhZGlvT3JDaGVja2JveEZ1bmN0aW9uKHJlZik7XHJcbiAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW25hbWVdO1xyXG4gICAgICAgIGxldCBpc0VtcHR5RGVmYXVsdFZhbHVlID0gdHJ1ZTtcclxuICAgICAgICBsZXQgaXNGaWVsZEFycmF5O1xyXG4gICAgICAgIGxldCBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgaWYgKGlzUmFkaW9PckNoZWNrYm94XHJcbiAgICAgICAgICAgID8gZmllbGQgJiZcclxuICAgICAgICAgICAgICAgIGlzQXJyYXkoZmllbGQub3B0aW9ucykgJiZcclxuICAgICAgICAgICAgICAgIGZpZWxkLm9wdGlvbnMuZmlsdGVyKEJvb2xlYW4pLmZpbmQoKG9wdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3B0aW9uLnJlZi52YWx1ZSAmJiBvcHRpb24ucmVmID09PSByZWY7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IGZpZWxkICYmIHJlZiA9PT0gZmllbGQucmVmKSB7XHJcbiAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGQpLCB2YWxpZGF0ZU9wdGlvbnMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uV2F0Y2hlciA9IG9uRG9tUmVtb3ZlKHJlZiwgKCkgPT4gcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyQW5kUmVmKGZpZWxkKSk7XHJcbiAgICAgICAgICAgIGZpZWxkID0gaXNSYWRpb09yQ2hlY2tib3hcclxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7IG9wdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKChmaWVsZCAmJiBmaWVsZC5vcHRpb25zKSB8fCBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uV2F0Y2hlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBdLCByZWY6IHsgdHlwZSwgbmFtZSB9IH0sIHZhbGlkYXRlT3B0aW9ucykgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkUmVmQW5kVmFsaWRhdGlvbk9wdGlvbnMpLCB7IG11dGF0aW9uV2F0Y2hlciB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpZWxkID0gZmllbGRSZWZBbmRWYWxpZGF0aW9uT3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgICAgZmllbGRzW25hbWVdID0gZmllbGQ7XHJcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCkpIHtcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlzRW1wdHlEZWZhdWx0VmFsdWUgPSBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICBpc0ZpZWxkQXJyYXkgPSBpc05hbWVJbkZpZWxkQXJyYXkoZmllbGRBcnJheU5hbWVzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzRW1wdHlEZWZhdWx0VmFsdWUgJiYgIWlzRmllbGRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgc2V0RmllbGRWYWx1ZShmaWVsZCwgZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkVmFsaWRhdGVTY2hlbWFPclJlc29sdmVyICYmXHJcbiAgICAgICAgICAgICFpc0ZpZWxkQXJyYXkgJiZcclxuICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVTY2hlbWFPclJlc29sdmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFpc0VtcHR5T2JqZWN0KHZhbGlkYXRlT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudC5hZGQobmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNPblN1Ym1pdCAmJiByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVGaWVsZChmaWVsZHNSZWYsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZmllbGQpLnRoZW4oKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGb3JtSXNWYWxpZCA9IGlzVmFsaWRSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5T2JqZWN0KGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuYWRkKG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGlzVmFsaWRSZWYuY3VycmVudCA9IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNGb3JtSXNWYWxpZCAhPT0gaXNWYWxpZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudFtuYW1lXSAmJlxyXG4gICAgICAgICAgICAhKGlzRmllbGRBcnJheSAmJiBpc0VtcHR5RGVmYXVsdFZhbHVlKSkge1xyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudFtuYW1lXSA9IGlzRW1wdHlEZWZhdWx0VmFsdWUgPyBnZXRGaWVsZFZhbHVlKGZpZWxkcywgZmllbGQucmVmKSA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoe1xyXG4gICAgICAgICAgICAgICAgZmllbGQ6IGlzUmFkaW9PckNoZWNrYm94ICYmIGZpZWxkLm9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLm9wdGlvbnNbZmllbGQub3B0aW9ucy5sZW5ndGggLSAxXVxyXG4gICAgICAgICAgICAgICAgICAgIDogZmllbGQsXHJcbiAgICAgICAgICAgICAgICBpc1JhZGlvT3JDaGVja2JveDogaXNSYWRpb09yQ2hlY2tib3ggfHwgaXNTZWxlY3RJbnB1dChyZWYpLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlQ2hhbmdlOiBoYW5kbGVDaGFuZ2VSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXIocmVmT3JWYWxpZGF0aW9uT3B0aW9ucywgdmFsaWRhdGlvbk9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoaXNXaW5kb3dVbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTdHJpbmcocmVmT3JWYWxpZGF0aW9uT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJGaWVsZHNSZWYoeyBuYW1lOiByZWZPclZhbGlkYXRpb25PcHRpb25zIH0sIHZhbGlkYXRpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3QocmVmT3JWYWxpZGF0aW9uT3B0aW9ucykgJiYgJ25hbWUnIGluIHJlZk9yVmFsaWRhdGlvbk9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJGaWVsZHNSZWYocmVmT3JWYWxpZGF0aW9uT3B0aW9ucywgdmFsaWRhdGlvbk9wdGlvbnMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAocmVmKSA9PiByZWYgJiYgcmVnaXN0ZXJGaWVsZHNSZWYocmVmLCByZWZPclZhbGlkYXRpb25PcHRpb25zKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKChjYWxsYmFjaykgPT4gYXN5bmMgKGUpID0+IHtcclxuICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGUucGVyc2lzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZmllbGRFcnJvcnMgPSB7fTtcclxuICAgICAgICBjb25zdCBmaWVsZHMgPSBmaWVsZHNSZWYuY3VycmVudDtcclxuICAgICAgICBsZXQgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZHNWYWx1ZXMoZmllbGRzKTtcclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzU3VibWl0dGluZykge1xyXG4gICAgICAgICAgICBpc1N1Ym1pdHRpbmdSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3JzLCB2YWx1ZXMgfSA9IGF3YWl0IHZhbGlkYXRlV2l0aFNjaGVtYSh2YWxpZGF0aW9uU2NoZW1hLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHRyYW5zZm9ybVRvTmVzdE9iamVjdChmaWVsZFZhbHVlcyksIHZhbGlkYXRpb25SZXNvbHZlciwgdmFsaWRhdGlvbkNvbnRleHRSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnNSZWYuY3VycmVudCA9IGVycm9ycztcclxuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzID0gZXJyb3JzO1xyXG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIE9iamVjdC52YWx1ZXMoZmllbGRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlZjogeyBuYW1lIH0sIH0gPSBmaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRFcnJvciA9IGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGRzUmVmLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGZpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkRXJyb3JbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldChmaWVsZEVycm9ycywgbmFtZSwgZmllbGRFcnJvcltuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZEZpZWxkc1JlZi5jdXJyZW50LmRlbGV0ZShuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50LmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuYWRkKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KGZpZWxkRXJyb3JzKSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JzUmVmLmN1cnJlbnQgPSB7fTtcclxuICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjYWxsYmFjayh0cmFuc2Zvcm1Ub05lc3RPYmplY3QoZmllbGRWYWx1ZXMpLCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVycm9yc1JlZi5jdXJyZW50ID0gZmllbGRFcnJvcnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VibWl0Rm9jdXNFcnJvciAmJiBpc1dlYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzT25FcnJvckZpZWxkKGZpZWxkcywgZmllbGRFcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBpc1N1Ym1pdHRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgaXNTdWJtaXR0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgc3VibWl0Q291bnRSZWYuY3VycmVudCA9IHN1Ym1pdENvdW50UmVmLmN1cnJlbnQgKyAxO1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtcclxuICAgICAgICBpc1dlYixcclxuICAgICAgICByZVJlbmRlcixcclxuICAgICAgICBzaG91bGRWYWxpZGF0ZVNjaGVtYU9yUmVzb2x2ZXIsXHJcbiAgICAgICAgc3VibWl0Rm9jdXNFcnJvcixcclxuICAgICAgICB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsXHJcbiAgICAgICAgdmFsaWRhdGlvblJlc29sdmVyLFxyXG4gICAgICAgIHZhbGlkYXRpb25TY2hlbWEsXHJcbiAgICBdKTtcclxuICAgIGNvbnN0IHJlc2V0UmVmcyA9ICh7IGVycm9ycywgZGlydHksIGlzU3VibWl0dGVkLCB0b3VjaGVkLCBpc1ZhbGlkLCBzdWJtaXRDb3VudCwgZGlydHlGaWVsZHMsIH0pID0+IHtcclxuICAgICAgICBmaWVsZHNSZWYuY3VycmVudCA9IHt9O1xyXG4gICAgICAgIGlmICghZXJyb3JzKSB7XHJcbiAgICAgICAgICAgIGVycm9yc1JlZi5jdXJyZW50ID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdG91Y2hlZCkge1xyXG4gICAgICAgICAgICB0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGlzVmFsaWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGlydHkpIHtcclxuICAgICAgICAgICAgaXNEaXJ0eVJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGlydHlGaWVsZHMpIHtcclxuICAgICAgICAgICAgZGlydHlGaWVsZHNSZWYuY3VycmVudCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1N1Ym1pdHRlZCkge1xyXG4gICAgICAgICAgICBpc1N1Ym1pdHRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3VibWl0Q291bnQpIHtcclxuICAgICAgICAgICAgc3VibWl0Q291bnRSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZi5jdXJyZW50ID0ge307XHJcbiAgICAgICAgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMuY3VycmVudCA9IHt9O1xyXG4gICAgICAgIHdhdGNoRmllbGRzUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgaXNXYXRjaEFsbFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzZXQgPSAodmFsdWVzLCBvbWl0UmVzZXRTdGF0ZSA9IHt9KSA9PiB7XHJcbiAgICAgICAgaWYgKGlzV2ViKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LnZhbHVlcyhmaWVsZHNSZWYuY3VycmVudCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVmLCBvcHRpb25zIH0gPSBmaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dFJlZiA9IGlzUmFkaW9PckNoZWNrYm94RnVuY3Rpb24ocmVmKSAmJiBpc0FycmF5KG9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3B0aW9uc1swXS5yZWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoaW5wdXRSZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFJlZi5jbG9zZXN0KCdmb3JtJykucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50ID0gdmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QudmFsdWVzKHJlc2V0RmllbGRBcnJheUZ1bmN0aW9uUmVmLmN1cnJlbnQpLmZvckVhY2goKHJlc2V0RmllbGRBcnJheSkgPT4gaXNGdW5jdGlvbihyZXNldEZpZWxkQXJyYXkpICYmIHJlc2V0RmllbGRBcnJheSgpKTtcclxuICAgICAgICByZXNldFJlZnMob21pdFJlc2V0U3RhdGUpO1xyXG4gICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVzKHBheWxvYWQpIHtcclxuICAgICAgICBpZiAoaXNTdHJpbmcocGF5bG9hZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkc1JlZi5jdXJyZW50W3BheWxvYWRdXHJcbiAgICAgICAgICAgICAgICA/IGdldEZpZWxkVmFsdWUoZmllbGRzUmVmLmN1cnJlbnQsIGZpZWxkc1JlZi5jdXJyZW50W3BheWxvYWRdLnJlZilcclxuICAgICAgICAgICAgICAgIDogZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgcGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZi5jdXJyZW50KTtcclxuICAgICAgICBjb25zdCBvdXRwdXRWYWx1ZXMgPSBpc0VtcHR5T2JqZWN0KGZpZWxkVmFsdWVzKVxyXG4gICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudFxyXG4gICAgICAgICAgICA6IGZpZWxkVmFsdWVzO1xyXG4gICAgICAgIHJldHVybiBwYXlsb2FkICYmIHBheWxvYWQubmVzdFxyXG4gICAgICAgICAgICA/IHRyYW5zZm9ybVRvTmVzdE9iamVjdChvdXRwdXRWYWx1ZXMpXHJcbiAgICAgICAgICAgIDogb3V0cHV0VmFsdWVzO1xyXG4gICAgfVxyXG4gICAgdXNlRWZmZWN0KCgpID0+ICgpID0+IHtcclxuICAgICAgICBpc1VuTW91bnQuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgZmllbGRzUmVmLmN1cnJlbnQgJiZcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGZpZWxkc1JlZi5jdXJyZW50KS5mb3JFYWNoKChmaWVsZCkgPT4gcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyQW5kUmVmKGZpZWxkLCB0cnVlKSk7XHJcbiAgICB9LCBbcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyQW5kUmVmXSk7XHJcbiAgICBpZiAoIXNob3VsZFZhbGlkYXRlU2NoZW1hT3JSZXNvbHZlcikge1xyXG4gICAgICAgIGlzVmFsaWRSZWYuY3VycmVudCA9XHJcbiAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuc2l6ZSA+PSBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50LnNpemUgJiZcclxuICAgICAgICAgICAgICAgIGlzRW1wdHlPYmplY3QoZXJyb3JzUmVmLmN1cnJlbnQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZm9ybVN0YXRlID0ge1xyXG4gICAgICAgIGRpcnR5OiBpc0RpcnR5UmVmLmN1cnJlbnQsXHJcbiAgICAgICAgZGlydHlGaWVsZHM6IGRpcnR5RmllbGRzUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGlzU3VibWl0dGVkUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgc3VibWl0Q291bnQ6IHN1Ym1pdENvdW50UmVmLmN1cnJlbnQsXHJcbiAgICAgICAgdG91Y2hlZDogdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50LFxyXG4gICAgICAgIGlzU3VibWl0dGluZzogaXNTdWJtaXR0aW5nUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgaXNWYWxpZDogaXNPblN1Ym1pdFxyXG4gICAgICAgICAgICA/IGlzU3VibWl0dGVkUmVmLmN1cnJlbnQgJiYgaXNFbXB0eU9iamVjdChlcnJvcnNSZWYuY3VycmVudClcclxuICAgICAgICAgICAgOiBpc1ZhbGlkUmVmLmN1cnJlbnQsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgY29tbW9uUHJvcHMgPSB7XHJcbiAgICAgICAgdHJpZ2dlclZhbGlkYXRpb24sXHJcbiAgICAgICAgc2V0VmFsdWU6IHVzZUNhbGxiYWNrKHNldFZhbHVlLCBbXHJcbiAgICAgICAgICAgIHJlUmVuZGVyLFxyXG4gICAgICAgICAgICBzZXRJbnRlcm5hbFZhbHVlLFxyXG4gICAgICAgICAgICB0cmlnZ2VyVmFsaWRhdGlvbixcclxuICAgICAgICBdKSxcclxuICAgICAgICByZWdpc3RlcjogdXNlQ2FsbGJhY2socmVnaXN0ZXIsIFtcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudCxcclxuICAgICAgICBdKSxcclxuICAgICAgICB1bnJlZ2lzdGVyOiB1c2VDYWxsYmFjayh1bnJlZ2lzdGVyLCBbXSksXHJcbiAgICAgICAgZ2V0VmFsdWVzOiB1c2VDYWxsYmFjayhnZXRWYWx1ZXMsIFtdKSxcclxuICAgICAgICBmb3JtU3RhdGU6IGlzUHJveHlFbmFibGVkXHJcbiAgICAgICAgICAgID8gbmV3IFByb3h5KGZvcm1TdGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiAob2JqLCBwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudFtwcm9wXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IGZvcm1TdGF0ZSxcclxuICAgIH07XHJcbiAgICBjb25zdCBjb250cm9sID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIsXHJcbiAgICAgICAgcmVSZW5kZXIgfSwgKHNob3VsZFZhbGlkYXRlU2NoZW1hT3JSZXNvbHZlclxyXG4gICAgICAgID8geyB2YWxpZGF0ZVNjaGVtYUlzVmFsaWQ6IHZhbGlkYXRlU2NoZW1hT3JSZXNvbHZlciB9XHJcbiAgICAgICAgOiB7fSkpLCB7IG1vZGU6IHtcclxuICAgICAgICAgICAgaXNPbkJsdXIsXHJcbiAgICAgICAgICAgIGlzT25TdWJtaXQsXHJcbiAgICAgICAgICAgIGlzT25DaGFuZ2UsXHJcbiAgICAgICAgfSwgcmVWYWxpZGF0ZU1vZGU6IHtcclxuICAgICAgICAgICAgaXNSZVZhbGlkYXRlT25CbHVyLFxyXG4gICAgICAgICAgICBpc1JlVmFsaWRhdGVPblN1Ym1pdCxcclxuICAgICAgICB9LCBlcnJvcnNSZWYsXHJcbiAgICAgICAgdG91Y2hlZEZpZWxkc1JlZixcclxuICAgICAgICBmaWVsZHNSZWYsXHJcbiAgICAgICAgaXNXYXRjaEFsbFJlZixcclxuICAgICAgICB3YXRjaEZpZWxkc1JlZixcclxuICAgICAgICByZXNldEZpZWxkQXJyYXlGdW5jdGlvblJlZixcclxuICAgICAgICBmaWVsZEFycmF5RGVmYXVsdFZhbHVlcyxcclxuICAgICAgICB2YWxpZEZpZWxkc1JlZixcclxuICAgICAgICBkaXJ0eUZpZWxkc1JlZixcclxuICAgICAgICBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZixcclxuICAgICAgICBmaWVsZEFycmF5TmFtZXNSZWYsXHJcbiAgICAgICAgaXNEaXJ0eVJlZixcclxuICAgICAgICByZWFkRm9ybVN0YXRlUmVmLFxyXG4gICAgICAgIGRlZmF1bHRWYWx1ZXNSZWYgfSksIGNvbW1vblByb3BzKTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgd2F0Y2gsXHJcbiAgICAgICAgY29udHJvbCxcclxuICAgICAgICBoYW5kbGVTdWJtaXQsIHJlc2V0OiB1c2VDYWxsYmFjayhyZXNldCwgW10pLCBjbGVhckVycm9yOiB1c2VDYWxsYmFjayhjbGVhckVycm9yLCBbXSksIHNldEVycm9yOiB1c2VDYWxsYmFjayhzZXRFcnJvciwgW10pLCBlcnJvcnM6IGVycm9yc1JlZi5jdXJyZW50IH0sIGNvbW1vblByb3BzKTtcclxufVxuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmNvbnN0IEZvcm1HbG9iYWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuZnVuY3Rpb24gdXNlRm9ybUNvbnRleHQoKSB7XHJcbiAgICByZXR1cm4gdXNlQ29udGV4dChGb3JtR2xvYmFsQ29udGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gRm9ybUNvbnRleHQoX2EpIHtcclxuICAgIHZhciB7IGNoaWxkcmVuLCBmb3JtU3RhdGUsIGVycm9ycyB9ID0gX2EsIHJlc3RNZXRob2RzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImZvcm1TdGF0ZVwiLCBcImVycm9yc1wiXSk7XHJcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRm9ybUdsb2JhbENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdE1ldGhvZHMpLCB7IGZvcm1TdGF0ZSwgZXJyb3JzIH0pIH0sIGNoaWxkcmVuKSk7XHJcbn1cblxudmFyIGdlbmVyYXRlSWQgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBkID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBVTkRFRklORUQgPyBEYXRlLm5vdygpIDogcGVyZm9ybWFuY2Uubm93KCkgKiAxMDAwO1xyXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNiArIGQpICUgMTYgfCAwO1xyXG4gICAgICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XHJcbiAgICB9KTtcclxufTtcblxuY29uc3QgYXBwZW5kSWQgPSAodmFsdWUsIGtleU5hbWUpID0+IChPYmplY3QuYXNzaWduKHsgW2tleU5hbWVdOiBnZW5lcmF0ZUlkKCkgfSwgKGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogeyB2YWx1ZSB9KSkpO1xyXG5jb25zdCBtYXBJZHMgPSAoZGF0YSwga2V5TmFtZSkgPT4gKGlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW10pLm1hcCgodmFsdWUpID0+IGFwcGVuZElkKHZhbHVlLCBrZXlOYW1lKSk7XG5cbnZhciBnZXRTb3J0UmVtb3ZlZEl0ZW1zID0gKGluZGV4ZXMsIHJlbW92ZUluZGV4ZXMsIHVwZGF0ZWRJbmRleGVzID0gW10sIGNvdW50ID0gMCwgbm90Rm91bmRJbmRleGVzID0gW10pID0+IHtcclxuICAgIGZvciAoY29uc3QgcmVtb3ZlSW5kZXggb2YgcmVtb3ZlSW5kZXhlcykge1xyXG4gICAgICAgIGlmIChpbmRleGVzLmluZGV4T2YocmVtb3ZlSW5kZXgpIDwgMCkge1xyXG4gICAgICAgICAgICBub3RGb3VuZEluZGV4ZXMucHVzaChyZW1vdmVJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzLnNvcnQoKSkge1xyXG4gICAgICAgIGlmIChyZW1vdmVJbmRleGVzLmluZGV4T2YoaW5kZXgpID4gLTEpIHtcclxuICAgICAgICAgICAgdXBkYXRlZEluZGV4ZXMucHVzaCgtMSk7XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1cGRhdGVkSW5kZXhlcy5wdXNoKGluZGV4IC1cclxuICAgICAgICAgICAgICAgIGNvdW50IC1cclxuICAgICAgICAgICAgICAgIChub3RGb3VuZEluZGV4ZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgPyBub3RGb3VuZEluZGV4ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgobm90Rm91bmRJbmRleCkgPT4gbm90Rm91bmRJbmRleCA8IGluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIDogMCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1cGRhdGVkSW5kZXhlcztcclxufTtcblxuY29uc3QgcmVtb3ZlQXQgPSAoZGF0YSwgaW5kZXgpID0+IFtcclxuICAgIC4uLmRhdGEuc2xpY2UoMCwgaW5kZXgpLFxyXG4gICAgLi4uZGF0YS5zbGljZShpbmRleCArIDEpLFxyXG5dO1xyXG5mdW5jdGlvbiByZW1vdmVBdEluZGV4ZXMoZGF0YSwgaW5kZXgpIHtcclxuICAgIGxldCBrID0gLTE7XHJcbiAgICB3aGlsZSAoKytrIDwgZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoaW5kZXguaW5kZXhPZihrKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhW2tdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhLmZpbHRlcihCb29sZWFuKTtcclxufVxyXG52YXIgcmVtb3ZlQXJyYXlBdCA9IChkYXRhLCBpbmRleCkgPT4gaXNVbmRlZmluZWQoaW5kZXgpXHJcbiAgICA/IFtdXHJcbiAgICA6IGlzQXJyYXkoaW5kZXgpXHJcbiAgICAgICAgPyByZW1vdmVBdEluZGV4ZXMoZGF0YSwgaW5kZXgpXHJcbiAgICAgICAgOiByZW1vdmVBdChkYXRhLCBpbmRleCk7XG5cbnZhciBtb3ZlQXJyYXlBdCA9IChkYXRhLCBmcm9tLCB0bykgPT4gaXNBcnJheShkYXRhKSA/IGRhdGEuc3BsaWNlKHRvLCAwLCBkYXRhLnNwbGljZShmcm9tLCAxKVswXSkgOiBbXTtcblxudmFyIHN3YXBBcnJheUF0ID0gKGRhdGEsIGluZGV4QSwgaW5kZXhCKSA9PiB7XHJcbiAgICBjb25zdCB0ZW1wID0gW2RhdGFbaW5kZXhCXSwgZGF0YVtpbmRleEFdXTtcclxuICAgIGRhdGFbaW5kZXhBXSA9IHRlbXBbMF07XHJcbiAgICBkYXRhW2luZGV4Ql0gPSB0ZW1wWzFdO1xyXG59O1xuXG5mdW5jdGlvbiBwcmVwZW5kKGRhdGEsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gWy4uLihpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlIHx8IG51bGxdKSwgLi4uZGF0YV07XHJcbn1cblxuZnVuY3Rpb24gaW5zZXJ0KGRhdGEsIGluZGV4LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICAuLi5kYXRhLnNsaWNlKDAsIGluZGV4KSxcclxuICAgICAgICAuLi4oaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZSB8fCBudWxsXSksXHJcbiAgICAgICAgLi4uZGF0YS5zbGljZShpbmRleCksXHJcbiAgICBdO1xyXG59XG5cbnZhciBmaWxsRW1wdHlBcnJheSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyBBcnJheSh2YWx1ZS5sZW5ndGgpLmZpbGwobnVsbCkgOiBudWxsO1xuXG5jb25zdCB1c2VGaWVsZEFycmF5ID0gKHsgY29udHJvbCwgbmFtZSwga2V5TmFtZSA9ICdpZCcsIH0pID0+IHtcclxuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xyXG4gICAgY29uc3QgeyBpc1dhdGNoQWxsUmVmLCByZXNldEZpZWxkQXJyYXlGdW5jdGlvblJlZiwgZmllbGRBcnJheU5hbWVzUmVmLCByZVJlbmRlciwgZmllbGRzUmVmLCBnZXRWYWx1ZXMsIGRlZmF1bHRWYWx1ZXNSZWYsIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lciwgZXJyb3JzUmVmLCBkaXJ0eUZpZWxkc1JlZiwgaXNEaXJ0eVJlZiwgdG91Y2hlZEZpZWxkc1JlZiwgcmVhZEZvcm1TdGF0ZVJlZiwgd2F0Y2hGaWVsZHNSZWYsIHZhbGlkRmllbGRzUmVmLCBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZiwgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMsIHZhbGlkYXRlU2NoZW1hSXNWYWxpZCwgfSA9IGNvbnRyb2wgfHwgbWV0aG9kcy5jb250cm9sO1xyXG4gICAgY29uc3QgZ2V0RGVmYXVsdFZhbHVlcyA9ICgpID0+IFtcclxuICAgICAgICAuLi5nZXQoZmllbGRBcnJheURlZmF1bHRWYWx1ZXMuY3VycmVudFtnZXRGaWVsZEFycmF5UGFyZW50TmFtZShuYW1lKV1cclxuICAgICAgICAgICAgPyBmaWVsZEFycmF5RGVmYXVsdFZhbHVlcy5jdXJyZW50XHJcbiAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lLCBbXSksXHJcbiAgICBdO1xyXG4gICAgY29uc3QgbWVtb2l6ZWREZWZhdWx0VmFsdWVzID0gdXNlUmVmKGdldERlZmF1bHRWYWx1ZXMoKSk7XHJcbiAgICBjb25zdCBbZmllbGRzLCBzZXRGaWVsZF0gPSB1c2VTdGF0ZShtYXBJZHMobWVtb2l6ZWREZWZhdWx0VmFsdWVzLmN1cnJlbnQsIGtleU5hbWUpKTtcclxuICAgIGNvbnN0IFtpc0RlbGV0ZWQsIHNldElzRGVsZXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBhbGxGaWVsZHMgPSB1c2VSZWYoZmllbGRzKTtcclxuICAgIGNvbnN0IGlzTmFtZUtleSA9IGlzS2V5KG5hbWUpO1xyXG4gICAgYWxsRmllbGRzLmN1cnJlbnQgPSBmaWVsZHM7XHJcbiAgICBpZiAoaXNOYW1lS2V5KSB7XHJcbiAgICAgICAgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMuY3VycmVudFtuYW1lXSA9IG1lbW9pemVkRGVmYXVsdFZhbHVlcy5jdXJyZW50O1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXBwZW5kVmFsdWVXaXRoS2V5ID0gKHZhbHVlcykgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IGFwcGVuZElkKHZhbHVlLCBrZXlOYW1lKSk7XHJcbiAgICBjb25zdCBzZXRGaWVsZEFuZFZhbGlkU3RhdGUgPSAoZmllbGRzVmFsdWVzKSA9PiB7XHJcbiAgICAgICAgc2V0RmllbGQoZmllbGRzVmFsdWVzKTtcclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgJiYgdmFsaWRhdGVTY2hlbWFJc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlU2NoZW1hSXNWYWxpZCh7XHJcbiAgICAgICAgICAgICAgICBbbmFtZV06IGZpZWxkc1ZhbHVlcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vZGlmeURpcnR5RmllbGRzID0gKHsgc2hvdWxkUmVuZGVyLCBpc1JlbW92ZSwgaXNQcmVQZW5kLCBpbmRleCwgdmFsdWUgPSB7fSwgfSA9IHt9KSA9PiB7XHJcbiAgICAgICAgbGV0IHJlbmRlciA9IHNob3VsZFJlbmRlcjtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcnR5RmllbGRJbmRleGVzQW5kVmFsdWVzID0ge307XHJcbiAgICAgICAgICAgIGlmIChpc1ByZVBlbmQgfHwgaXNSZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGlydHlGaWVsZCBvZiBbLi4uZGlydHlGaWVsZHNSZWYuY3VycmVudF0uc29ydCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2hGaWVsZEFycmF5TmFtZShkaXJ0eUZpZWxkLCBuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkSW5kZXhlcyA9IGRpcnR5RmllbGQubWF0Y2goUkVHRVhfQVJSQVlfRklFTERfSU5ERVgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZEluZGV4ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSArbWF0Y2hlZEluZGV4ZXNbbWF0Y2hlZEluZGV4ZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlydHlGaWVsZEluZGV4ZXNBbmRWYWx1ZXNbbWF0Y2hJbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkSW5kZXhlc0FuZFZhbHVlc1ttYXRjaEluZGV4XS5wdXNoKGRpcnR5RmllbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZEluZGV4ZXNBbmRWYWx1ZXNbbWF0Y2hJbmRleF0gPSBbZGlydHlGaWVsZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZHNSZWYuY3VycmVudC5kZWxldGUoZGlydHlGaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoaW5kZXgpIHx8IGlzUHJlUGVuZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZERpcnR5RmllbGRJbmRleGVzID0gaXNVbmRlZmluZWQoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBbXVxyXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0U29ydFJlbW92ZWRJdGVtcyhPYmplY3Qua2V5cyhkaXJ0eUZpZWxkSW5kZXhlc0FuZFZhbHVlcykubWFwKChpKSA9PiAraSksIGlzQXJyYXkoaW5kZXgpID8gaW5kZXggOiBbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXMoZGlydHlGaWVsZEluZGV4ZXNBbmRWYWx1ZXMpLmZvckVhY2goKHZhbHVlcywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVJbmRleCA9IGlzUHJlUGVuZCA/IDAgOiB1cGRhdGVkRGlydHlGaWVsZEluZGV4ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkSW5kZXhlcyA9IHZhbHVlLm1hdGNoKFJFR0VYX0FSUkFZX0ZJRUxEX0lOREVYKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkSW5kZXhlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzUmVmLmN1cnJlbnQuYWRkKHZhbHVlLnJlcGxhY2UoL1tcXGQrXShbXltcXGQrXSspJC8sIGAke2lzUHJlUGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICttYXRjaGVkSW5kZXhlc1ttYXRjaGVkSW5kZXhlcy5sZW5ndGggLSAxXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdXBkYXRlSW5kZXh9JDFgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgoZmllbGRWYWx1ZSwgaW5kZXgpID0+IE9iamVjdC5rZXlzKGZpZWxkVmFsdWUpLmZvckVhY2goKGtleSkgPT4gZGlydHlGaWVsZHNSZWYuY3VycmVudC5hZGQoYCR7bmFtZX1bJHtpc1ByZVBlbmQgPyBpbmRleCA6IGFsbEZpZWxkcy5jdXJyZW50Lmxlbmd0aCArIGluZGV4fV0uJHtrZXl9YCkpKTtcclxuICAgICAgICAgICAgICAgIGlzRGlydHlSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbmRlciAmJiAhaXNXYXRjaEFsbFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc2V0RmllbGRzID0gKGZsYWdPckZpZWxkcykgPT4ge1xyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHkpIHtcclxuICAgICAgICAgICAgaXNEaXJ0eVJlZi5jdXJyZW50ID0gaXNVbmRlZmluZWQoZmxhZ09yRmllbGRzKVxyXG4gICAgICAgICAgICAgICAgPyB0cnVlXHJcbiAgICAgICAgICAgICAgICA6IGdldElzRmllbGRzRGlmZmVyZW50KGZsYWdPckZpZWxkcywgZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50W25hbWVdIHx8IFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGlzTWF0Y2hGaWVsZEFycmF5TmFtZShrZXksIG5hbWUpICYmIGZpZWxkc1JlZi5jdXJyZW50W2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lcihmaWVsZHNSZWYuY3VycmVudFtrZXldLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtYXBDdXJyZW50RmllbGRzVmFsdWVXaXRoU3RhdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZpZWxkc1ZhbHVlID0gZ2V0KGdldFZhbHVlcyh7IG5lc3Q6IHRydWUgfSksIG5hbWUpO1xyXG4gICAgICAgIGlmIChpc0FycmF5KGN1cnJlbnRGaWVsZHNWYWx1ZSkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50RmllbGRzVmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFsbEZpZWxkcy5jdXJyZW50W2ldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhbGxGaWVsZHMuY3VycmVudFtpXSksIGN1cnJlbnRGaWVsZHNWYWx1ZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgYXBwZW5kID0gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgc2V0RmllbGRBbmRWYWxpZFN0YXRlKFtcclxuICAgICAgICAgICAgLi4uYWxsRmllbGRzLmN1cnJlbnQsXHJcbiAgICAgICAgICAgIC4uLihpc0FycmF5KHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgPyBhcHBlbmRWYWx1ZVdpdGhLZXkodmFsdWUpXHJcbiAgICAgICAgICAgICAgICA6IFthcHBlbmRJZCh2YWx1ZSwga2V5TmFtZSldKSxcclxuICAgICAgICBdKTtcclxuICAgICAgICBtb2RpZnlEaXJ0eUZpZWxkcyh7IHZhbHVlIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByZXBlbmQkMSA9ICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGxldCBzaG91bGRSZW5kZXIgPSBmYWxzZTtcclxuICAgICAgICByZXNldEZpZWxkcygpO1xyXG4gICAgICAgIHNldEZpZWxkQW5kVmFsaWRTdGF0ZShwcmVwZW5kKGFsbEZpZWxkcy5jdXJyZW50LCBpc0FycmF5KHZhbHVlKSA/IGFwcGVuZFZhbHVlV2l0aEtleSh2YWx1ZSkgOiBbYXBwZW5kSWQodmFsdWUsIGtleU5hbWUpXSkpO1xyXG4gICAgICAgIGlmIChlcnJvcnNSZWYuY3VycmVudFtuYW1lXSkge1xyXG4gICAgICAgICAgICBlcnJvcnNSZWYuY3VycmVudFtuYW1lXSA9IHByZXBlbmQoZXJyb3JzUmVmLmN1cnJlbnRbbmFtZV0sIGZpbGxFbXB0eUFycmF5KHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCAmJiB0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnRbbmFtZV0pIHtcclxuICAgICAgICAgICAgdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdID0gcHJlcGVuZCh0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnRbbmFtZV0sIGZpbGxFbXB0eUFycmF5KHZhbHVlKSk7XHJcbiAgICAgICAgICAgIHNob3VsZFJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vZGlmeURpcnR5RmllbGRzKHtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyLFxyXG4gICAgICAgICAgICBpc1ByZVBlbmQ6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZSA9IChpbmRleCkgPT4ge1xyXG4gICAgICAgIGxldCBzaG91bGRSZW5kZXIgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBpc0luZGV4VW5kZWZpbmVkID0gaXNVbmRlZmluZWQoaW5kZXgpO1xyXG4gICAgICAgIGlmICghaXNJbmRleFVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBtYXBDdXJyZW50RmllbGRzVmFsdWVXaXRoU3RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzZXRGaWVsZHMocmVtb3ZlQXJyYXlBdChnZXRGaWVsZFZhbHVlQnlOYW1lKGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSwgaW5kZXgpKTtcclxuICAgICAgICBzZXRGaWVsZEFuZFZhbGlkU3RhdGUocmVtb3ZlQXJyYXlBdChhbGxGaWVsZHMuY3VycmVudCwgaW5kZXgpKTtcclxuICAgICAgICBzZXRJc0RlbGV0ZWQodHJ1ZSk7XHJcbiAgICAgICAgaWYgKGVycm9yc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIGVycm9yc1JlZi5jdXJyZW50W25hbWVdID0gcmVtb3ZlQXJyYXlBdChlcnJvcnNSZWYuY3VycmVudFtuYW1lXSwgaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoIWVycm9yc1JlZi5jdXJyZW50W25hbWVdLmZpbHRlcihCb29sZWFuKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlcnJvcnNSZWYuY3VycmVudFtuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiYgdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudFtuYW1lXSA9IHJlbW92ZUFycmF5QXQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdLCBpbmRleCk7XHJcbiAgICAgICAgICAgIHNob3VsZFJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZCAmJiAhdmFsaWRhdGVTY2hlbWFJc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIGxldCBmaWVsZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGxldCBpc0ZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW5kZXhVbmRlZmluZWQgPSBpc1VuZGVmaW5lZChpbmRleCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChmaWVsZEluZGV4KysgPCBmaWVsZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0xhc3QgPSBmaWVsZEluZGV4ID09PSBmaWVsZHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudEluZGV4ID0gKGlzQXJyYXkoaW5kZXgpID8gaW5kZXggOiBbaW5kZXhdKS5pbmRleE9mKGZpZWxkSW5kZXgpID49IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50SW5kZXggfHwgaXNJbmRleFVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZHNbZmllbGRJbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmllbGROYW1lID0gYCR7bmFtZX1bJHtmaWVsZEluZGV4fV0uJHtrZXl9YDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50SW5kZXggfHwgaXNMYXN0IHx8IGlzSW5kZXhVbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRGaWVsZHNSZWYuY3VycmVudC5kZWxldGUoY3VycmVudEZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQuZGVsZXRlKGN1cnJlbnRGaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGaWVsZE5hbWUgPSBgJHtuYW1lfVske2ZpZWxkSW5kZXggLSAxfV0uJHtrZXl9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuaGFzKGN1cnJlbnRGaWVsZE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZEZpZWxkc1JlZi5jdXJyZW50LmFkZChwcmV2aW91c0ZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQuaGFzKGN1cnJlbnRGaWVsZE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50LmFkZChwcmV2aW91c0ZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbW9kaWZ5RGlydHlGaWVsZHMoe1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXIsXHJcbiAgICAgICAgICAgIGlzUmVtb3ZlOiB0cnVlLFxyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBjb25zdCBpbnNlcnQkMSA9IChpbmRleCwgdmFsdWUpID0+IHtcclxuICAgICAgICBtYXBDdXJyZW50RmllbGRzVmFsdWVXaXRoU3RhdGUoKTtcclxuICAgICAgICByZXNldEZpZWxkcyhpbnNlcnQoZ2V0RmllbGRWYWx1ZUJ5TmFtZShmaWVsZHNSZWYuY3VycmVudCwgbmFtZSksIGluZGV4KSk7XHJcbiAgICAgICAgc2V0RmllbGRBbmRWYWxpZFN0YXRlKGluc2VydChhbGxGaWVsZHMuY3VycmVudCwgaW5kZXgsIGlzQXJyYXkodmFsdWUpID8gYXBwZW5kVmFsdWVXaXRoS2V5KHZhbHVlKSA6IFthcHBlbmRJZCh2YWx1ZSwga2V5TmFtZSldKSk7XHJcbiAgICAgICAgaWYgKGVycm9yc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIGVycm9yc1JlZi5jdXJyZW50W25hbWVdID0gaW5zZXJ0KGVycm9yc1JlZi5jdXJyZW50W25hbWVdLCBpbmRleCwgZmlsbEVtcHR5QXJyYXkodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC50b3VjaGVkICYmIHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudFtuYW1lXSkge1xyXG4gICAgICAgICAgICB0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnRbbmFtZV0gPSBpbnNlcnQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdLCBpbmRleCwgZmlsbEVtcHR5QXJyYXkodmFsdWUpKTtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc3dhcCA9IChpbmRleEEsIGluZGV4QikgPT4ge1xyXG4gICAgICAgIG1hcEN1cnJlbnRGaWVsZHNWYWx1ZVdpdGhTdGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZUJ5TmFtZShmaWVsZHNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgc3dhcEFycmF5QXQoZmllbGRWYWx1ZXMsIGluZGV4QSwgaW5kZXhCKTtcclxuICAgICAgICByZXNldEZpZWxkcyhmaWVsZFZhbHVlcyk7XHJcbiAgICAgICAgc3dhcEFycmF5QXQoYWxsRmllbGRzLmN1cnJlbnQsIGluZGV4QSwgaW5kZXhCKTtcclxuICAgICAgICBzZXRGaWVsZEFuZFZhbGlkU3RhdGUoWy4uLmFsbEZpZWxkcy5jdXJyZW50XSk7XHJcbiAgICAgICAgaWYgKGVycm9yc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIHN3YXBBcnJheUF0KGVycm9yc1JlZi5jdXJyZW50W25hbWVdLCBpbmRleEEsIGluZGV4Qik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCAmJiB0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnRbbmFtZV0pIHtcclxuICAgICAgICAgICAgc3dhcEFycmF5QXQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdLCBpbmRleEEsIGluZGV4Qik7XHJcbiAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmUgPSAoZnJvbSwgdG8pID0+IHtcclxuICAgICAgICBtYXBDdXJyZW50RmllbGRzVmFsdWVXaXRoU3RhdGUoKTtcclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVCeU5hbWUoZmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgIG1vdmVBcnJheUF0KGZpZWxkVmFsdWVzLCBmcm9tLCB0byk7XHJcbiAgICAgICAgcmVzZXRGaWVsZHMoZmllbGRWYWx1ZXMpO1xyXG4gICAgICAgIG1vdmVBcnJheUF0KGFsbEZpZWxkcy5jdXJyZW50LCBmcm9tLCB0byk7XHJcbiAgICAgICAgc2V0RmllbGRBbmRWYWxpZFN0YXRlKFsuLi5hbGxGaWVsZHMuY3VycmVudF0pO1xyXG4gICAgICAgIGlmIChlcnJvcnNSZWYuY3VycmVudFtuYW1lXSkge1xyXG4gICAgICAgICAgICBtb3ZlQXJyYXlBdChlcnJvcnNSZWYuY3VycmVudFtuYW1lXSwgZnJvbSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiYgdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIG1vdmVBcnJheUF0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudFtuYW1lXSwgZnJvbSwgdG8pO1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcclxuICAgICAgICByZXNldEZpZWxkcygpO1xyXG4gICAgICAgIG1lbW9pemVkRGVmYXVsdFZhbHVlcy5jdXJyZW50ID0gZ2V0RGVmYXVsdFZhbHVlcygpO1xyXG4gICAgICAgIHNldEZpZWxkKG1hcElkcyhtZW1vaXplZERlZmF1bHRWYWx1ZXMuY3VycmVudCwga2V5TmFtZSkpO1xyXG4gICAgfTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzTmFtZUtleSAmJlxyXG4gICAgICAgICAgICBpc0RlbGV0ZWQgJiZcclxuICAgICAgICAgICAgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMuY3VycmVudFtuYW1lXSAmJlxyXG4gICAgICAgICAgICBmaWVsZHMubGVuZ3RoIDwgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMuY3VycmVudFtuYW1lXS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMuY3VycmVudFtuYW1lXS5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbZmllbGRzLCBuYW1lLCBmaWVsZEFycmF5RGVmYXVsdFZhbHVlcywgaXNEZWxldGVkLCBpc05hbWVLZXldKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzV2F0Y2hBbGxSZWYgJiYgaXNXYXRjaEFsbFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHdhdGNoRmllbGRzUmVmKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd2F0Y2hGaWVsZCBvZiB3YXRjaEZpZWxkc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hGaWVsZC5zdGFydHNXaXRoKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtmaWVsZHMsIG5hbWUsIHJlUmVuZGVyLCB3YXRjaEZpZWxkc1JlZiwgaXNXYXRjaEFsbFJlZl0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCByZXNldEZ1bmN0aW9ucyA9IHJlc2V0RmllbGRBcnJheUZ1bmN0aW9uUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgZmllbGRBcnJheU5hbWVzID0gZmllbGRBcnJheU5hbWVzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgZmllbGRBcnJheU5hbWVzLmFkZChuYW1lKTtcclxuICAgICAgICByZXNldEZ1bmN0aW9uc1tuYW1lXSA9IHJlc2V0O1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlc2V0RmllbGRzKCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSByZXNldEZ1bmN0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgZmllbGRBcnJheU5hbWVzLmRlbGV0ZShuYW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3dhcDogdXNlQ2FsbGJhY2soc3dhcCwgW25hbWVdKSxcclxuICAgICAgICBtb3ZlOiB1c2VDYWxsYmFjayhtb3ZlLCBbbmFtZV0pLFxyXG4gICAgICAgIHByZXBlbmQ6IHVzZUNhbGxiYWNrKHByZXBlbmQkMSwgW25hbWVdKSxcclxuICAgICAgICBhcHBlbmQ6IHVzZUNhbGxiYWNrKGFwcGVuZCwgW25hbWVdKSxcclxuICAgICAgICByZW1vdmU6IHVzZUNhbGxiYWNrKHJlbW92ZSwgW2ZpZWxkcywgbmFtZV0pLFxyXG4gICAgICAgIGluc2VydDogdXNlQ2FsbGJhY2soaW5zZXJ0JDEsIFtuYW1lXSksXHJcbiAgICAgICAgZmllbGRzLFxyXG4gICAgfTtcclxufTtcblxudmFyIGdldElucHV0VmFsdWUgPSAoZXZlbnQsIGlzQ2hlY2tib3hJbnB1dCkgPT4gaXNQcmltaXRpdmUoZXZlbnQpIHx8XHJcbiAgICAhaXNPYmplY3QoZXZlbnQudGFyZ2V0KSB8fFxyXG4gICAgKGlzT2JqZWN0KGV2ZW50LnRhcmdldCkgJiYgIWV2ZW50LnR5cGUpXHJcbiAgICA/IGV2ZW50XHJcbiAgICA6IGlzQ2hlY2tib3hJbnB1dCB8fCBpc1VuZGVmaW5lZChldmVudC50YXJnZXQudmFsdWUpXHJcbiAgICAgICAgPyBldmVudC50YXJnZXQuY2hlY2tlZFxyXG4gICAgICAgIDogZXZlbnQudGFyZ2V0LnZhbHVlO1xuXG5jb25zdCBDb250cm9sbGVyID0gKF9hKSA9PiB7XHJcbiAgICB2YXIgeyBuYW1lLCBydWxlcywgYXM6IElubmVyQ29tcG9uZW50LCBvbkJsdXIsIG9uQ2hhbmdlLCBvbkNoYW5nZU5hbWUgPSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsIG9uQmx1ck5hbWUgPSBWQUxJREFUSU9OX01PREUub25CbHVyLCB2YWx1ZU5hbWUsIGRlZmF1bHRWYWx1ZSwgY29udHJvbCwgb25Gb2N1cyB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcIm5hbWVcIiwgXCJydWxlc1wiLCBcImFzXCIsIFwib25CbHVyXCIsIFwib25DaGFuZ2VcIiwgXCJvbkNoYW5nZU5hbWVcIiwgXCJvbkJsdXJOYW1lXCIsIFwidmFsdWVOYW1lXCIsIFwiZGVmYXVsdFZhbHVlXCIsIFwiY29udHJvbFwiLCBcIm9uRm9jdXNcIl0pO1xyXG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XHJcbiAgICBjb25zdCB7IGRlZmF1bHRWYWx1ZXNSZWYsIHNldFZhbHVlLCByZWdpc3RlciwgdW5yZWdpc3RlciwgZXJyb3JzUmVmLCByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIsIHRyaWdnZXJWYWxpZGF0aW9uLCBtb2RlOiB7IGlzT25TdWJtaXQsIGlzT25CbHVyLCBpc09uQ2hhbmdlIH0sIHJlVmFsaWRhdGVNb2RlOiB7IGlzUmVWYWxpZGF0ZU9uQmx1ciwgaXNSZVZhbGlkYXRlT25TdWJtaXQgfSwgZm9ybVN0YXRlOiB7IGlzU3VibWl0dGVkIH0sIHRvdWNoZWRGaWVsZHNSZWYsIHJlYWRGb3JtU3RhdGVSZWYsIHJlUmVuZGVyLCBmaWVsZHNSZWYsIGZpZWxkQXJyYXlOYW1lc1JlZiwgfSA9IGNvbnRyb2wgfHwgbWV0aG9kcy5jb250cm9sO1xyXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRJbnB1dFN0YXRlVmFsdWVdID0gdXNlU3RhdGUoaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKVxyXG4gICAgICAgID8gZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSlcclxuICAgICAgICA6IGRlZmF1bHRWYWx1ZSk7XHJcbiAgICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZih2YWx1ZSk7XHJcbiAgICBjb25zdCBpc0NoZWNrYm94SW5wdXQgPSBpc0Jvb2xlYW4odmFsdWUpO1xyXG4gICAgY29uc3Qgc2hvdWxkUmVWYWxpZGF0ZU9uQmx1ciA9IGlzT25CbHVyIHx8IGlzUmVWYWxpZGF0ZU9uQmx1cjtcclxuICAgIGNvbnN0IHJ1bGVzUmVmID0gdXNlUmVmKHJ1bGVzKTtcclxuICAgIGNvbnN0IG9uRm9jdXNSZWYgPSB1c2VSZWYob25Gb2N1cyk7XHJcbiAgICBjb25zdCBpc05vdEZpZWxkQXJyYXkgPSAhaXNOYW1lSW5GaWVsZEFycmF5KGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgIHJ1bGVzUmVmLmN1cnJlbnQgPSBydWxlcztcclxuICAgIGNvbnN0IHNob3VsZFZhbGlkYXRlID0gKCkgPT4gIXNraXBWYWxpZGF0aW9uKHtcclxuICAgICAgICBoYXNFcnJvcjogISFnZXQoZXJyb3JzUmVmLmN1cnJlbnQsIG5hbWUpLFxyXG4gICAgICAgIGlzT25CbHVyLFxyXG4gICAgICAgIGlzT25TdWJtaXQsXHJcbiAgICAgICAgaXNPbkNoYW5nZSxcclxuICAgICAgICBpc1JlVmFsaWRhdGVPbkJsdXIsXHJcbiAgICAgICAgaXNSZVZhbGlkYXRlT25TdWJtaXQsXHJcbiAgICAgICAgaXNTdWJtaXR0ZWQsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNvbW1vblRhc2sgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gZ2V0SW5wdXRWYWx1ZShldmVudCwgaXNDaGVja2JveElucHV0KTtcclxuICAgICAgICBzZXRJbnB1dFN0YXRlVmFsdWUoZGF0YSk7XHJcbiAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGRhdGE7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZXZlbnRXcmFwcGVyID0gKGV2ZW50KSA9PiAoLi4uYXJnKSA9PiBzZXRWYWx1ZShuYW1lLCBjb21tb25UYXNrKGV2ZW50KGFyZykpLCBzaG91bGRWYWxpZGF0ZSgpKTtcclxuICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb21tb25UYXNrKGV2ZW50KTtcclxuICAgICAgICBzZXRWYWx1ZShuYW1lLCBkYXRhLCBzaG91bGRWYWxpZGF0ZSgpKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZWdpc3RlckZpZWxkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICghaXNOb3RGaWVsZEFycmF5KSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lcihmaWVsZHNSZWYuY3VycmVudFtuYW1lXSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZ2lzdGVyKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7IG5hbWUsIGZvY3VzOiBvbkZvY3VzUmVmLmN1cnJlbnQgfSwgVkFMVUUsIHtcclxuICAgICAgICAgICAgc2V0KGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHNldElucHV0U3RhdGVWYWx1ZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBkYXRhO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSwgcnVsZXNSZWYuY3VycmVudCk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgaXNOb3RGaWVsZEFycmF5LFxyXG4gICAgICAgIGZpZWxkc1JlZixcclxuICAgICAgICBydWxlc1JlZixcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIG9uRm9jdXNSZWYsXHJcbiAgICAgICAgcmVnaXN0ZXIsXHJcbiAgICAgICAgcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyLFxyXG4gICAgXSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4ge1xyXG4gICAgICAgICFpc05hbWVJbkZpZWxkQXJyYXkoZmllbGRBcnJheU5hbWVzUmVmLmN1cnJlbnQsIG5hbWUpICYmIHVucmVnaXN0ZXIobmFtZSk7XHJcbiAgICB9LCBbdW5yZWdpc3RlciwgbmFtZSwgZmllbGRBcnJheU5hbWVzUmVmXSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJlZ2lzdGVyRmllbGQoKTtcclxuICAgIH0sIFtyZWdpc3RlckZpZWxkXSk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghZmllbGRzUmVmLmN1cnJlbnRbbmFtZV0pIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJGaWVsZCgpO1xyXG4gICAgICAgICAgICBpZiAoaXNOb3RGaWVsZEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRJbnB1dFN0YXRlVmFsdWUoaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG5hbWUgfSwgcmVzdCksIChvbkNoYW5nZVxyXG4gICAgICAgID8geyBbb25DaGFuZ2VOYW1lXTogZXZlbnRXcmFwcGVyKG9uQ2hhbmdlKSB9XHJcbiAgICAgICAgOiB7IFtvbkNoYW5nZU5hbWVdOiBoYW5kbGVDaGFuZ2UgfSkpLCB7IFtvbkJsdXJOYW1lXTogKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uQmx1cikge1xyXG4gICAgICAgICAgICAgICAgb25CbHVyKGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCAmJlxyXG4gICAgICAgICAgICAgICAgIWdldCh0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50LCBuYW1lLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNob3VsZFJlVmFsaWRhdGVPbkJsdXIpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJWYWxpZGF0aW9uKG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB9KSwgeyBbdmFsdWVOYW1lIHx8IChpc0NoZWNrYm94SW5wdXQgPyAnY2hlY2tlZCcgOiBWQUxVRSldOiB2YWx1ZSB9KTtcclxuICAgIHJldHVybiBpc1ZhbGlkRWxlbWVudChJbm5lckNvbXBvbmVudClcclxuICAgICAgICA/IGNsb25lRWxlbWVudChJbm5lckNvbXBvbmVudCwgcHJvcHMpXHJcbiAgICAgICAgOiBjcmVhdGVFbGVtZW50KElubmVyQ29tcG9uZW50LCBwcm9wcyk7XHJcbn07XG5cbmNvbnN0IEVycm9yTWVzc2FnZSA9IChfYSkgPT4ge1xyXG4gICAgdmFyIHsgYXM6IElubmVyQ29tcG9uZW50LCBlcnJvcnMsIG5hbWUsIG1lc3NhZ2UsIGNoaWxkcmVuIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiYXNcIiwgXCJlcnJvcnNcIiwgXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcImNoaWxkcmVuXCJdKTtcclxuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xyXG4gICAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzIHx8IG1ldGhvZHMuZXJyb3JzLCBuYW1lKTtcclxuICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbWVzc2FnZTogbWVzc2FnZUZyb21SZWdpc3RlciwgdHlwZXMgfSA9IGVycm9yO1xyXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChJbm5lckNvbXBvbmVudCA/IHJlc3QgOiB7fSkpLCB7IGNoaWxkcmVuOiBjaGlsZHJlblxyXG4gICAgICAgICAgICA/IGNoaWxkcmVuKHsgbWVzc2FnZTogbWVzc2FnZUZyb21SZWdpc3RlciB8fCBtZXNzYWdlLCBtZXNzYWdlczogdHlwZXMgfSlcclxuICAgICAgICAgICAgOiBtZXNzYWdlRnJvbVJlZ2lzdGVyIHx8IG1lc3NhZ2UgfSk7XHJcbiAgICByZXR1cm4gSW5uZXJDb21wb25lbnQgPyAoaXNWYWxpZEVsZW1lbnQoSW5uZXJDb21wb25lbnQpID8gKGNsb25lRWxlbWVudChJbm5lckNvbXBvbmVudCwgcHJvcHMpKSA6IChjcmVhdGVFbGVtZW50KElubmVyQ29tcG9uZW50LCBwcm9wcykpKSA6IChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpKTtcclxufTtcblxuZXhwb3J0IHsgQ29udHJvbGxlciwgRXJyb3JNZXNzYWdlLCBGb3JtQ29udGV4dCwgdXNlRmllbGRBcnJheSwgdXNlRm9ybSwgdXNlRm9ybUNvbnRleHQgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-hook-form/dist/react-hook-form.es.js\n");

/***/ })

})